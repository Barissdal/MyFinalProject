
CORE Katmaný = Framework yapacaðýz bu yaptýðýmýzý farklý projelerimizde de kullanabileceðiz. Bunu EfProductDal ve EfCategoryDal için yapmamýz gerekiyor çünkü bunlar ayný þeyleri yapýyor sadece alýnan paremetreler deðiþiyor.
Bunun için Class Library oluþturmalýyýz. Core -> Class Library

Bu CORE Katmanýnda evrensel kodlarýmý yazabilirim.

CORE Katmanýnda DataAccess folderý data access için evrensel kodlarýmý yazýyorum demektir.

NameSpace : Classlarý Interface lerý belli bir isim uzayýnda býrakýyoruz ki rahatça eriþebilielim diye.

***CORE Katmaný diðer katmanlarý referans almaz.Ozaman sadece o projeye baðýmlý olacaktýr bunu istemiyoruz.

IEntityRepository ve IEntity katmanlarýnýn Nortwind database i ile bir baðlantýsý yok. Bunlar global oyüden CORE Katmanýna atmamýz lazým.

CORE Katamnýna da veri tabaný eklememiz lazým oyüden Solutiýn sað click manage nuget aç ýnstall de EntityFrameWrodkCoreSQLSERVER'I CORA EKLE

EfProductDal artýk EfEntitiyRepositoryBase'i inherit alacaktýr. Çünkü IProductDal'a iliþkin methodlar artýk orada.
Burada IProductDal'ý da inherit etmemiz lazým. Bunu farklý server'lar baðlamak için lazým. IProductDal'ý product tablosuna iliþkin operasyonlarý kullanmak için kullanacaðýz.

Yeni bir Order class ý eklemek istersek;
1) Entities Class Library'de Order Class ý oluþturulur.
2) Data Access Class Library'de Abstract'ta Interfacý oluþturulur ve bu Interface IEntityRepository olduðu implement et.
3) Data Access Class Library'de EntityFrameWork'te EfOrderDal'ý hazýrla. Bunun da EfEntityRepositoryBase<Order, NorthwindContext>,IOrderDal olduðunu belirt.
Bundan sonra tüm sql operasyonlarýn hazýr olmuþ oluyor.

4) Veri tabaný Context'inde database'deki tablo ile bu yeni oluþturdum Order Class'ýnýn baðlamam lazým.

5) Business'ta Abstract Interface oluþturacaðýz. Burada Order'la ilgili dýþ dünyaya neyi servis etmek istiyorsak o operasyonlarý yazýyoruz.

6) Business Concrete'te Order'ýn iþ sýnýflarýný yazýyoruz.


7) Businnes manager sýnýflarýma Data Access'teki ilgili Interface'i implement ediyorum IOrderDal _orderDal;

8) Program.cs'de de daha önce yazdýðýmz kodlarý metod haline getirmek için seçip sað clikten quick actions refractoring ' i seçip metod yaptýk.

9) DTO (Data Transformation Object) : Join gibi operasyonlarý yapýyoruz. Entities'te klasor olarak oluþtur.

10) DTOs clasorunde ProductDetailDto classý oluþtur.

11) Core altýnda Entitites'te IDtos interface i oluþturulmalýdýr.
ProductDetailDto:IDto yapmayý unutma.

12) DataAccess'teki Interface'lerde join yapýsý oluþturulacak.

10.GÜN SONU KAYIT NOTLARI WEB API

1) Business'ta IProductService Add metodu ekleyelim.
2)Web API, yazdýðýmýz kodlarýn bir Angular, IOS vb. uygulamalarýn
anlamasýný saðlar.
WEB API ,Restful denilen bir formatla çalýþan json uygulamalarý
3) Client'larýn WEB API'ye yapacaklarý Requestler ile bizim vereceðimiz
Response larý yönetebilmek için bir alt yapý kuracaðýz.
4) Bu Request'lere Response döndürecekler Business'taki Managerlerdir.
Oyüden orasý için Base bir katman yazacaðýz.
5)Business'ta IProductService GetById metodu ekleyelim.
6) Bir metodtta sadece bir þey döndürebilirsin ama bir den fazla þey döndürmek istersen
Encapsulation yapman lazým.
7) Core Katmanýna Utilities(Araçlar) folderý ekleyelim.
8) Utilities'te de bir Results klasorü ekleyeceðiz Response larýmýz için.
Bu Result klasörü bizim result larýmýzý düenleyecek.
9) Result klasöründe IResult interfacý oluþturalým.
10) IResult ýn somut classýný Result olarak oluþtur.
11) Result'ta IResult ý implement ettikten sonra return tarafýna {get;}
12) IProductService eklediðimiz Add metodunu void deðil artýk IResult döndürmeli
13) ProductManager'da da ilgili void yerine IResult yapýyoruz. (Add metodu)
14) Bu Add metoduna return olarak artýk Result vermeliyiz.
15) return new Result(true,"Ürün eklendi.");
16) Burada Result'a çift týklayýp ampülden üsttekini seçiyoruz ve Reulst'a F12 ile gidiyoruz.
17) private deðiþkenleri ve metodun içindeki this leri siliyoruz.
17) Result'ta contructor kurulduðu için burada Message=message yapýyoruz yani aslýnda sadece get yapýlabilen deðiþlenleri
Contructor ile set leyebiliyoruz.
18) Add çalýþtýktan sonra mesaj döndürmek istemiyorsak ne yapacaðýz?
19) succes ve message parametresi alan constructor ý overload edecek sadece succes
parametresi alan bir Result contructor daha yazýyoruz.
20) public Result(bool success, string message):this(success)
        {
            Message = message;
        }

        public Result(bool success)
        {
            Success = success;
        }
21) this ile Result'ýn sadece success alan parametreli contructorý da çalýþþýn diyoruz.
22) Dolayýsýyla ProductManager'da IResult döndüren Add methodunda
iki parametreli Result'ý new lersen Result.cs de iki contructor da çalýþacak.
23) Bu yapýyý þimdi biraz daha profesyonel yapalým. SuccessResult, ErrorResult vb.
24) Results folderýnda SuccessResult yaratalým bu ayný zamanda Result,
burada Result contructor içerdiði için SuccessResult içinde constructor olmalý
25)SuccessResult construtorý oluþturuyoruz ve ;
public SuccessResult(string message):base(true,message) böyle tanýmlýyoruz
Buradaki base aslýnda Result'ý iþaret etmektedir.
Resulttaki ilk constructor success ve message parametreleri alýyordu.
Burada da succes olduðu için ona true diyoruz ve bir message parametresi giriyoruz.
26)ProductManager'da artýk add metodunda result yerine successresult ý çaðýrabiliriz.
27) ErrorResult ' ta oluþturalým.
28) ErrorResult için Business katmanýnda döndüreceðimiz string ler için bir yapý oluþturacaðýz.
29)Business ta Constants folder ý oluþturalým. Veritabanýmýza özel proje sabitlerini burada oluþtururuz.
30) Constants'ta Messages static bir class oluþturalým. Static verdiðimizde new lemeyz.
31)ProductManager'da artýk ErrorResult ve SuccesResult'ta Messages daki statik sabitlerimizi çaðýrabiliriz.
32)IProductService te GetAll için de IDataResult döndürsün.
Hem data, hem mesajý, hemde iþlem sonucu içeren bir yapýyý görevi görsün.
33) Core-Utilities-Results altýnda IDataResult interface oluþturalým.
Bu IDataResult ayný zamanda bir de IResult olacak çünkü orada mesaj ve iþlem sonucu da içermektedir.
34)IProductService'teki GetAll'da IDataResult<List<Product>> döndürecek.
Add metodu IResult kalýyor çünkü o bir void metottu Data içermiyor.
35)ProductManager'daki interface metodlarý artýk IDataResult istediði için onlarý güncelleyeceðiz.
Ayrýca return'lerde IDataResult'ýn somutu olan DataResult döndürmeliyiz.
Bunun için Results folderý na DataResult class ý oluþturalým.
Bunun Result'tan farklý data da içermesidir.
36) DataResult, hem Result hem de IDataResult 'týr.
37) Result için SuccessResult ve ErrorResult yaptýk;
DataResult için de SuccessDataResult ve ErrorDataResult yapalým.
38)SuccesDataResult ta çeþitli versiyonlar oluþturuyoruz.
39)Benzer þeyleri ErrorDataResult için de yap ve true larý false yapalaým.
40) ProductManager da return'lerde artýk ErrorDataResult ve SuccessDataResult new lenecek.
41) Program.cs'de ProductTest metodunda GetProductDetails artýk IDataResult döndürüyor onun için metodun
sonuna .Data yapalým.
42) ProductTest'te if koþullarý ekliyoruz.
43)Messages classýnda MaintenanceTime ile ProductsListed'ý string olarak açýklamasýný yazalým.
Onlarý da public yap internal yerine.


11.GÜN SONU KAYIT NOTLARI WEB API

Asp.net, .net projelerideki wep projesidir.
Api, bir Restful mimariyi destekler.
Restful mimari bizim geliþtiridðimiz .net'i tanýmayan sistemlerin entegre olmasýný saðlayan ortamdýr.

1) Solution üerinde Add Project -> Asp.net core web application
WebAPI için API'yý seçip uygun core versionumzu seçip create yapýyoruz.

2) Postmann test ortamýmýz.

3) WebAPI set as startup project yapýyoruz.

4) Controllers folder ý gelen bütün istekleri karþýlar.
Aslýnda bizim IProductService'teki metodlar için istek oluþturacaðýz.

5) Ä°stekler http ile gelecektir.

6) Controllers ta bize gelecek istekleri kodluyoruz aslýnda.

7) Controllers folderýna sað týkla Controllersý seç;
API'yý seçip empty olaný ekliyoruz. API'lerde controller isimleri çoðul yazýlýr.
Bu yüden ProductsController oluþturuyoruz.

8) ProductsController'de artýk Business'taki datalarý çaðýracaðýz.

9) Web API'ye, add project reference yapýyoruz.
Business, Core, DataAccess ve Entities için.

10) ProductsController' de Get için metod yazýyoruz List<Product> döndüren

11) Bir katman diðer katmanýn somutuyla baðlantý kurmamalý. !!!

12) IProductService'i constructor injection yapýypruz.

13) Bundan sonra çalýþtýrdðýmýzda hata alýyoruz çünkü Web Api somut bir nesne almadýðý için hangi
manageri döndüreceðini bilmiyor oyüden IoC devreye giriyor.

14) IoC Container aslýnda soyut varlýklarýmýzýn somutlarýný referans olarak tutan bir liste olarak
düþünebiliriz. Web Api'ye soyut varlýðýmýzý refere ettiðimizde onun IoC'deki somutunun referansýný döndürür.

15) WebApi'nin içinde Startup.cs ye gidiyoruz þimdi.

16) services.AddSingleton<IProductService,ProductManager>();
Sen IProductService görüyorsan bunu ProductManager new le diye ifade ederiz.
AddSingleton'ý içinde data tutmadýðýmýz yapýlar için kullanýrýz.

17) Burada da ProductManager contructor'ý da içinde IProductDal içerdiði için,
bunu da AddSingleton'da bunun EfProductDal olduðu ifade etmemiz lazým.

18) Bu yapýyý farklý bir mimariye taþýyacaðýz.
Autofac, Ninject, CastleWindsor, StructureMap, LightInject, DryInject -->IoC Container

19) Artýk AOP yapacaðýz.
AOP= Bütün metodlarýmýzý log lamak istediðimizde kullanýrýz.
Bir metodun önünde, sonunda ve ya bir metot hata verdiðinde çalýþan kodlarý
AOP'de yazýyoruz.  Log vb. için

20) Postman daki Status kýsmý Server'ýn ne döndürdüðünü ifade eder.
Ã–rneðin yetkisi olmayanlar için status 400K olur. Yni buradan alýnan yanýta göre ekran
yapýlandýrýlacak.

21) ProductController deki Get IActionResult olacak þekilde düeltelim.

22) Get metodunu result.Success ise döndüreceðimiz status için duruma göre Ok ve BadRequest olarak
döndürelim.

Çalýþtýrdýðýmýzda açýlan browser da url alanýna domain den sonra api/httpger ve ya post'un içine ne yazdýysak öyle çaðýrýyoruz.
örneðin domain/api/products/getall

23) ProductManager'da bu durumu test edelim çalýþtýðým saatte sistem bakýmda olsun.
Status'te ne dönecek test edelim.

24) Status 400 Bad Request olarak güncellendi sonuçta.
Çünkü ben saat 16:00'da sistem bakýmda dedim.

25) Åžimdi post requesti yazacaðýz.

[HttpPost]

26) Post metoduna nesne olarak Product'ý verebiliriz.

27) Post request'lerde data vermemiz lazým.
Postman'da Post'u seçip send dedikten sonra
Body -> raw -> JSON'ý seçelim. Burada JSON formatýnda Product giriþi yapmamýz lazým.
Bunun için Get'ti çalýþtýrýp oradan gelen JSON formatýný kopyalayabiliriz.

    {
        "categoryId": 1,
        "productName": "Bardak",
        "unitsInStock": 15,
        "unitPrice": 25
    }

28) Bunu send ettiðimizde artýk veritabanýna bu bilgileri ekler.

29) Bir Get daha oluþturalým. Bunun için ilkine [HttpGet("getall")]
ikincisine [HttpGet("getbyid")] ; post için de [HttpPost("add")]
Metotlarýn adýný da Get=GetAll vb. yapalým

30) Postman'da artýk GET'TE api/products/getall ; getbyid?id=1 
POST'TA api/products/add kullanarak veri giriþi yapabiliriz.

31) Update ve Delete içinde Post kullanýlabilir.Ama update içinde HttpPut da var.

12.GÜN SONU KAYIT NOTLARI WEB API

1) IoC altyapýsýný biraz daha ileri seviyeye taþýyacaðýz.

2) .Net'in kendi IoC altyapýsý olsa da AOP tekniklerini kullanmak için
baþka Container larla destekleyeceðiz.

3) Autofac ücretsiz ve daha hýzlý olduðu için kullanacaðýz;
Postsharp da çok iyi ama ücretlidir.

4) Autofac, instance üretimini bizim için saðlayan bir yapýya sahiptir.

5) Biz bu yapýlanmayý Startup.cs de yapmak yerine Back-end de yapmalýyýz.
Çünkü baþka bir api ve ya birden fazla api kullanacaksak ilerde bunu .Net Core içerisinde Containerlarý
kullanmamýz lazým.

6) Businnes üzerinde saða týkla Manage NuGet Packages ->
Browse -> autofac -> Autofac by Autofac Contributors -> 
Version son sürüm kullanýlabilir

7) Browse -> autofac.extras -> install
(Java daki Spring gibi)

8) Businnes ta bir klasor oluþturalým = DependencyResolvers

9) DependencyResolvers'ta da Service lerin ve Interface lerin karþýlýklarýný
autofac kullanarak belirtmiþ olacaðýz.

10) DependencyResolvers' ta Autofac klasörü oluþturalým.

11) Autofac içerisinde bir AutofacBusinessModule classý oluþturalým.

12) BU class a sen bir Module 'sun diyeceðiz ama buradaki Module; using Autofac;

13) over yaz space a baþ bekle orada ezebileceðimiz metodlarý görsterir.

14) Orada Load 'ý seçiyoruz.

//birisi senden IProductService isterse ona bir tabe ProductManager örneði ver.
builder.RegisterType<ProductManager>().As<IProductService>().SingleInstance();
builder.RegisterType<EfProductDal>().As<IProductDal>().SingleInstance();

15) Startup'a gidip daha önce yaptýðýmýz AddSingleton ' larý commentleyelim.

16) Bunlarýn yerine biz kendi Autofac yapýmýzý tanýtmamýz lazým.

17) Bunu Web API'DE Program.cs de yapacaðýz.

18) CreateHostBuilder metodunda .UseServiceProviderFactory(new AutofacServiceProviderFactory())

AutofacServiceProviderFactory için install package'ý ampulden yapalým.

19) .ConfigureContainer<ContainerBuilder>(builder=>
                {
                    builder.RegisterModule(new AutofacBusinessModule());
                })


20) Burada biz .Net'e kendi IoC yapýný kullanma benim AutofacBusinessModule'u kullanmalýsýn dedik.

21) Validation, varlýklarýn yapýsal kontrollerine bakar. Þifre bu kurallara uymalý, isim min 2 karekter olmalý gibi.

22) Business'ta ValidationRules folder ý oluþtur.

23) ValidationRules 'ta FluentValidation klasoru oluþturalým.

24) Business -> Manage Nuget Packages -> fluentvalidation (jeremy skinner) install

25) FluentValidation 'da ProductValidator classý ekle

26) Bu ProductValidator aslýnda AbstractValidator<Product>

27) Bu kurallar bir contructor içine yazýlýr.

28) RuleFor(c => c.DailyPrice).NotEmpty(); vb.

29) Burada yeni bir kuralda biz ekleyebiliriz.

30) Ürünlerimin ismi A ile baþlasýn kularý eklemek istersek;

	RuleFor(p=>p.ProductName).Must(StartWithA);

31) (StartWithA) 'ye generic metod dersen oluþturur.

32) private bool StartWithA(string arg)
        {
            return arg.StartsWith("A");
        }

33) ProductManager Add metodu içinde koþullarý silebiliriz artýk.

34) Add içinde ValidationContext i oluþturalým.

35) var context = new ValidationContext<Car>(car);
            CarValidator carValidator = new CarValidator();
            var result = carValidator.Validate(context);

            if (!result.IsValid)
            {
                throw new ValidationException(result.Errors);
            }


burada refactor edeceðiz. Çünkü yukardaki deðiþenler Car entity ve CarValidator

36) Bu yapý her yerde kullanabileceðim için Core a taþýmalýyým.

37) Corss Cutting Concerns, dikey kesen yapýlar (loglama , cache, validation , transaction, authorization vb.)

38) Core'da CrossCuttingConcerns folderý ekleyelim.

39) CrossCuttingConcerns'de Validation folderý ekleyelim.

40) Validation'da ValidationTool clasý oluþtur.

41) 35'teki kodu buraya atacaðýz ve bu class static olacak.

42) Bu classýn içinde Validate metodu oluþturacaðýz. Bu metod parametre olarak CarValidator için bir IValidator bir de entity için object alacak.

43) public static void Validate(IValidator validator, object entity )
        {
            var context = new ValidationContext<object>(entity);
            var result = validator.Validate(context);

            if (!result.IsValid)
            {
                throw new ValidationException(result.Errors);
            }
        }

44) CarManager'da bu yaptýðýmýz metodu çaðýrmamýz gerekecektir;

	ValidationTool.Validate(new CarValidator(),car);

45) Ama bunun gibi validation, loglama, cache, transaction, yetkilendirme gibi þeyler yapacaðýz bunlarýn hepsini
add metodunda alt alta yazmayalým.

46) Bu yapýlarý kurmak için Aspect kullanmalýyýz.

47) Aspect'ler için bazý kodlara ihtiyacýmýz var bunu Engin Hocanýn githubta NetCoreBackend projesinden alacaðýz.

48) Core-Utilities-Interceptors'ta AspectInterceptorSelector;MethodInterception;ModelInterceptionBaseAttiribute

49) AOP = Uygulamanýn metodun baþýnda, sonunda ve ya hata verdiðinde dizayn etmektir.

50) Core katmanýmýzda Utilites altýnda Interceptors folderý ekleyelim.

51) ModelInterceptionBaseAttiribute kodunu kopyala namespace dýþýndakileri

52) Interceptors folderýne bir class ekle isim verme þimdilik

53) class olan yere kopyaladýðýmýzý yapýþla.

54) Solution üzerinde Manage Nuget packages tan Install'da autofac olan 3ünü Core a ekleyeceðiz.

55) Github ta MethodInterception kodunu kopyalayalým.

56) Buradaki kodlar metotlarýn çalýþmadan önceki validationlarýný sorgulayacak alandýr.

57) Aspect'te burasý için hangi durumu doldurusak o çalýþacak OnBefore mu OnAfter mý vb.

58) Bu kopyaladýðýmýzý da oluþturduðumuz class a ekleyelim.

59) Github ta  AspectInterceptorSelector kopyala

60) Bu kod class'ýn , metotun attributelarýný oku bunlarý listele. Bunlarýn sýrasýný da önceliklerine göre sýrala.

61) Burada loglama kýsmýný commnet yapalým þimdilik.

62) MethodInfo yu çözersek hepsi düzelecektir.

63) Bu kopyalayýp yapýþtýrdýklarýmýzý ayýrmak için ModelInterceptionBaseAttiribute üzerine imleci býrak ampulden
move type to.... týkla

64) MethodInterception içinde aynýsýný yap son kalan içinde rename yapalým.

65) Core'a Aspects kalsoru ekle

66) Autofac'i kullanarak Aspects yazacaðýmýz için Aspects klasoru ekle.

67) Burada þimdi validation yapacaðýmýz için Validation klasoru ekle.

68) Github ta Core/Aspects/Autofac/Validation/ValidationAspect.cs kopyala

69) Validation klasorunde bizde class ekleyelim ve kopyaladýðýmýzý o class yerine yapýþtýrç

70) ValidationAscpect bir type ister. Örneðin Add metodunu CarValidator kullanarak doðrula deriz.

71) Manager'da artýk ValidationTool clasýnýn metoduna gerek kalmadý.
Add üstünde [ValidationAspect(typeof(CarValidator))] ekle.

72) Þu anda Manager'da add metounda validation yok ama aspect ekledik.

73) Þimdi bu Interceptor larýn devreye girmesini söylememiz lazým.

74) Githubta Business/DependencyResolvers/Autofac/AutofacBusinessModule.cs var assembly ile baþlayan kodu kopyala

Bu kod builder.daki butun sýnýflar için önce git Aspect'i var mý bak der.

75) Business/DependencyResolvers/Autofac/AutofacBusinessModule.cs da load metodunun içine yapýþtýralým.

#13.GÜN DERS NOTLARI

1) Örnek bir demo yapacaðýz AOP için bunu sileceðiz sonra

2) Business'ta CCS(Cross Cutting Conserns) folderý ekle.

3) Burada ILogger interfaci ekle

4) Burada void Log metodu olsun

5) CCS üzerinde FileLogger classý ekle

6) Bu FileLogger:ILogger 

7) Log metdounu implement edip bir açýklama ekrana yazdýralým.

8) Bir tane de DatabaseLogger clasýý ekleyelim ve Log metodunu yine yazalým.

9) ProductManager'deki ValidationAspect'i þimdilik comment yapalým.

10) ProductManager de bu ILogger interfaci construct injection yapalým.

11) Zaten ProductManager'ýn contructor ý var buraya ILogger'ý da ekliyoruzç

12) Bu ILogger interface Autofac'e tanýtmak için AutofacBusinessModule'de ILogger'ý da ekle

13) ProductManager'da Add metodunun içinde try catch yap

14) Metodu çaðýrma ve return'u try içine at, try'dan önce log metodunu çaðýr

15) Baþarýsýz olursa catch'te de log u çaðýr. Burada hem baþarýlý ekleme olursa
hemde baþarýsýz olursa log lama yaptýk.

16) try catch'den sonrada ErrorResult döndürebiliriz.

17) Burada iþ kodlarýmýz olabilir, diðer dikey kesenlerimiz olabilir burasý karmaþýk olur

18) Bu çalýþmalarý AOP ile merkezi bir noktaya taþýrýz.

19) Core'da Utilities'de Interceptors klasorunde MethotInterception class var.
Buradaki virtual metotlar ezilebilecek mototlardýr. 

20) Core.Aspects.Autofac.Validation da isim vermediðimiz class vardý onun ismini
rename yapalým ValidationAspect olarak.

21) Core.CrossCuttingConcerns.Validation da ValidationTool clasýmýz ;
Bir tane IValidator ve bir tane class istemektedir. 

22) ValidationAspect, metodun baþýnda sonunda hata verdiðinde çalýþacak yapýdýr.

23) Validation doðrulama olduðu için sadece OnBefore u tanýmlamýþtýk.

24) Clean Code yapýyoruz ....

25) Bir ürün eklemek istersem eklemek istediðim ürünün kategorisinde maksimum 
10 ürün olabilir. Bunun kodunu yazalým.

26) IProductService'te Update metodu yokmuþ onu ekleyelim.

27) Manager'da Update metodunu implement et ve baþýna validation ekle

28) 25'teki durumu add metodunda da kullanacaðýz update de de oyüzden kendimizi
tekrar etmemeiz lazým.

29) Bu yüzden bir iþ kuralý yazacaksak eðer manager'de en alta gelip fonksiyon(metot) olarak
yazmamýz gerekecektir.

30) Bu metot sadece manager class'ýnda kullanýlýndýðý için private olarak yazýlmalý.

31) Bu metodun adýný da CheckIfProductCountOfCategoryCorrect yazalým ve kod parçacýðýmýzý yazalým.

32) private IResult CheckIfProductCountOfCategoryCorrect(int categoryId)
        {
            var result = _productDal.GetAll(p => p.CategoryId == categoryId).Count;

            if (result >= 10)
            {
                return new ErrorResult(Messages.ProductCountOfCategoryError);
            }
            return new SuccessResult();
        }

33) Bu metodu artýk nerede kullanmak istersek kullanabiliriz.

34) if (CheckIfProductCountOfCategoryCorrect(product.CategoryId).Success)
            {
                _productDal.Add(product);

                return new SuccessResult(Messages.ProductAdded);
            }
            return new ErrorResult();

35) Ayný isimde ürün eklenemez

36) Bir metot daha ekleyip yukarýdaki if ile baðlayabiliriz.

37) CheckIfProductNameExists adýyla metot ekleriz.

38) Burada birden çok metot varsa iç içe bir sürü if olacak.

39) Bu yazdýðýmýz iþ kurallarýný refactor edelim. Çünkü iþ kurallarýmýz hep IResult döndürmektedir. Bunlarý þimdi bir
iþ motoru olarak yazalým. 

40) Bu iþ kurallarý bütün projelerde yapýlabilir çünkü zaten IResult yapýsý döndürdüðüm için bunlarý Core'da
tanýmlayabilirim.

41) Core-Utilities'de Business folderý ekle ve onda da BusinessRules classý ekle.

42) Burada da bir Run metodu yazalým.

43) ProductManager'da þimdi Business.Run metodunu içine daha önce yazdýðýmýz IResult döndüren 2 metodu verebiliriz.

44) Bu metot bir IResult döndürür oyüzden bunu bir IResult deðiþkenine atayalým ve burada kurala uymama koþulunu yazalým.

45) Artýk bu iþ kurallarýna göre add çalýþtýrýlabilir ve yeni bir iþ kuralý gelirse Business.Run metoduna ekle

46) Yeni kuralýmýz eðer mevcut kategori sayýsý 15'i geçtiyse sisteme yeni ürün eklenemez.

47) Bu kural microservice mimarisine nasýl yaklaþacaðýmýzý gösterecektir.

48) Bir entitymanager kendisi hariç baþka bir dal'ý enjekte edemez ama service enjekte edebiliriz.

49) Çünkü yeni kurallar geldiðinde ICategoryDal'ý her yerde yazman lazým.

50) CategoryDal için biz bir service yazdýk ve ona ait kurallarý orada belirtmiþtik zaten.

51) ICategoryService'i de refactor etmemiz lazým.

52) CategoryManager'da ilgili düzenlemeleri yap.

53) Her entity'nin kendi service olmalý.

54) Artýk ProductManager'da 46 nolu maddedeki koþul için metot yazabiliriz.

55) Bunu da artýk Business.Run içerisine ekleyebiliriz.

56) Program.cs ' de ProductManager'i çaðýrdýðýmýz için oraya da CategoryManager'i de ekleyelim.

57) Business.DependencyResolvers.Autofac'te AutofacBusinessModule'de CategoryManager ekle

#14.GÜN DERS NOTLARI

1) Add operasyonu için SecuredOperation diye bir aspect yazmak isteyeceðiz.

2) Bu metotu çaðýracak kiþinin admin,editor vb. yetkilere sahip olmasý gerekebilir.

3) Bu yetkilendirme ihtiyaca göre deðiþkendir.

4) Operasyon bazýnda da yetkilendirme yapmamýz gerekebilir.

5) Add metodunu admin yapsýn örneðin

6) Claim=Bu kullanýcýnýn admin gibi claimlerinden birine sahip olmasý gerekir;
Yani admin,editor vb. þeylere claim diyoruz.

7) Api bazlý yapýlarda json bazlý bir token dan yararlanýlýr = jwt(jsonwebtoken)

8) Encryption, Hashing bunlar karþý tarafýn verilerimizi okumamasýný saðlayacak yapýlar.

9) Kullanýcý parolalarý hash lenir.

10) Parolalar; MD5, SHA1 gibi hashleme algoritmalarýyla geri dönüþtürülemeyecek þekilde haslenir.

11) Kullanýcý ama þifresini girdiðinde hashlenmemiþ halini giriyor sonuçta kullanýcý log in butonuna týkladýktan sonra
yine hasleme algoritmasýyla o hashlenir ve veritabanýndaki hashlenmiþ verilerle karþýlaþtýrýlýr.

12) Salting, kullanýcýnýn girdiði parolayý biraz daha güçlendirme iþlemi.Bunu biz kendimiz ekliyoruz.

13) Encryption geri dönüþü olan veridir. Ýlgili data encrpt ediliyor ve bu da çözülebilir.

14) Burada key denilen anahtarlar ortaya çýkmaktadýr.

15) SeucredOperation için kullanýcýlar, kullanýcýlarýn claim leri ve bu ikisi iliþkilendirmek için 3 tabloya ihtiyaç var.

16) Northwind veritabanýnda Tables'da sað click Add New Table yapalým.

17) User tablosunu oluþturalým. Id alanýný sað click yapýp Properties'ten Identity alanýný true yapalým.

18) Update tuþu ile update edelim ve tabomuz oluþsun.

19) OperationClaims tablosu ayný þekilde oluþturalým.

20) UserOperationClaims tablosu ekle.

21) Þimdi bunlarýn Entity'de class larýný oluþturalým ama bunlarý bütün projelerimizde
kullanabileceðimiz için bunlarý Core'da Entities içerisine Concrete folder ý ekleyelim.
Burada class larý oluþturalým.

22) User, OperationClaim ve UserOperationClaim class larý ekleyelim.

23) Web API' de appsettings.json dosyasý var. Bu dosya WebAPI nin ayarlarýnýn olduðu yerdir.
Burada bizde TokenOptions adýyla bir anahtar oluþturacaðýz.

24) Jwt nin olmazsa olmaz alanlarýný burada yazalým.

25) "Audience",Issuer, AccessTokenExpiration(bizim verdiðimiz token nýn dakika olarak geçerlilik süresi)
SecurityKey(token için kullanýlacak anahtar ismi)

30) Core'da Utilities'de Security folderý ekleyelim.

31) Burada da Hashing, Encryption ve JWT klasorlerý ekleyelim.

32) Hashing'te bir tane hashlame aracý yazmak için bir HashingHelper class ekleyelim.

33) Bu classta iki metot olacak. Birisi hash leme yapacak ikincisi de doðrulama yapacak.

34) Encryption klasorunda SecurityKeyHelper class ý ekle

35) Biz bu yapýlarda herþeyi byte arrayi ile oluþturmamýz gerekir.

36) Core'da Manage Nuget Packages Browse -> Microsoft.Identity -> Model.Tokens install

37) SecurityKeyHelper classýndaki SecurityKey appsettings.json da tanýmladýðýmýz SecurityKey'dir.

38) Encryption klasorunda SigningCredentialsHelper classý ekle

39) Burada da bir güvenlik anahtarý ve þifreleme algoritmasýný tanýmlýyoruz. 

40) JWT klasorunde AccessToken classý ekle

41) Anlamsýz deðerlerden oluþan bir anahtar deðeri ve bir bitiþ tarihi bulunacak bu class ta

42) Bu AccessToken'ý oluþturmak için bir ITokenHelper interface i oluþturalým.
Ýlgili kullanýcýnýn claim lerini içerecek bir token üretecek

43) Engin Demirog Github'ýndan kodlar alacaðýz

44) NetCoreBackend/Core/Utilities/Security/Jwt/JwtHelper.cs  kodlarýna gelelim.
Bu kod CreateToken metodunu implemente ediyor.
Bir token da accessTokenExpiration olmalý token ne zaman bitecek,
Bu süreyi Configuration dan alýyor bu da bizim Web Api deki appsettings.json dosyamýzý okur
Security key için de appsettings.json'daki TokenOptions ý okur
signingCredentials'ta hangi algoritmayý kullanacaðýmýzý ifade eder
jwt üretmek için tokenOptionslar, user, signingCredentials(neyi kullanarak) ve bu user ýn claimleri

Buradaki kodlarý kopyalayalým.

45) Core/Utilities/Security/JWT folderýnda JwtHelper classý ekle

46) Oluþan class ý iptal edip kodu yapýþtýralým.

47) CreateToken içindeki User'ý çözelim önce

48) IConfiguration, Microsofttan gelir bizim api mizdeki appsettings i okumaya yarar

49) Burada okuduðumz deðerleri de bir nesneye atmamýz gerekir bunu da _tokenOptions'a atmaya çalýþacaðýz.

50) Bu TokenOptions için Github ta NetCoreBackend/Core/Utilities/Security/Jwt/TokenOptions.cs 'deki kodu kopyala

51) Core.Utilities.Security.JWT içinde TokenOptions class ý ekle ve class yerine kodu yapýþtýr.

52) Core -> Manage Nuget -> Browse -> system.identity install

53) Github ta Core/Extensions/ClaimExtensions.cs kodu kopyala

54) .NET'te bir nesneye yeni metotlar ekleyebiliriz. Bunu da Extensions la yaparýz.

55) Core'da Extensions folder ý ekle ve ClaimExtensions classý ekle

56) Extensions lar hem class ýn hem metotlarýn static olmasý gerekir .NET'te

57) Github ta Core/Extensions/ClaimsPrincipalExtensions.cs classý var kodu kopyala.
Bu bir kiþinin claim lerini ararken .NET bizi uðraþtýrýr 
Bir kiþinin jwt gelen claim lerini okumak için claimPrincipal metotu çalýþýr.
Bir kiþinin claimlerine eriþmek için .NET'TE olan class ve bunu da Extensions ediyoruz.

58) claimPrincipal? null olabileceðini gösterir.

59) Core'da Extensions folderýnda ClaimsPrincipalExtensions classý ekle ve kodu yapýþtýr

60) Yetkilendirme için Aspect kýsmý Business'ýn içine yazýlýr çünkü her proje için yetkilendirme deðiþebilir.

61) Business'ta BusinessAspects folderý ekle ve onda da Autofac folderý ekle

62) Orada da bir class ekle

63) Burada ProductManager'daki Add metounda önce yetkisi var mý yok mu diye aspect yazacaðýz

64) Github'ta Business/BusinessAspects/Autofac/SecuredOperation.cs kodunu kopyala

65) Bizim oluþturduðumuz class yerine ekle

66) Github'ta Core/Utilities/IoC/ServiceTool.cs kopyala
Burada .NET'in Collection larýný toplar burada istediðimiz Interface'lerýn karþýlýðýný buradan alabiliriz.

67) Core.Utilities'te IoC'de folder ý ekle ve class oluþtur

68) Kodu buraya yapýþtýr.

69) Bundan sonra bir pakete ihtiyacýmýz var. ServiceProvider. dediðimizde hiçbir metot gelmiyor

70) Solutions -> Manage Nuget Packages -> Install'de Autofac'leri tekrar install yapacaðýz Business'ta olmayanlarý

71) SecuredOperations class ýnda using Castle.DynamicProxy; ekle

72) Business -> Manage Nuget Packages -> Browse -> Microsoft.Extensions.DependencyInjection install

73) SecuredOperations class ýnda using Microsoft.Extensions.DependencyInjection; ekle

74) ProductManager da [SecuredOperation("product.add,admin")] add metoundan önce ekleyelim.

75) SecuredOperation.cs 'deki IHttpContextAccessor ASP.Net içinden gelen bir yapý

76) Biz bu SecuredOperation ý add metunda OnBefore da yaptýk.
O ani kullanýcýnýn ClaimRole lerini çöz. Bu kullanýcýnýn rollerini gez eðer claimlerinin içinde
ilgili rol varsa return et.

77) Github'ta DataAccess/Abstract/IUserDal.cs kopyala 

78) DataAccess.Abstract'ta class oluþtur ve kodu yapýþtýr 

79) Github'ta DataAccess/Concrete/EntityFramework/EfUserDal.cs kopyala

80) DataAccess.Concrete.EntityFrameWork class ekle ve kodu yapýþtýr

81) NorthwindContext'te bugun oluþturduðumuz 3 tabloyu burada nesnelerini tanýtmak lazým
        public DbSet<OperationClaim> OperationClaims { get; set; }
        public DbSet<User> Users { get; set; }
        public DbSet<UserOperationClaim> UserOperationClaims { get; set; }

82) EfUserDal'da context'te bir tabloyu göremiyor buna using System.Linq; ekle

83) Github'ta Business/Abstract/IUserService.cs kopyala
Aynýsýný sende ekle

84) Github'ta Business/Abstract/IAuthService.cs kopyala
Aynýsýný sende ekle; burada iki tane Dto var onlarý da Github'tan alýcaz

85) Entities/Dtos/UserForLoginDto.cs kopyala
aynýsýný ekle

86) Entities/Dtos/UserForRegisterDto.cs koyapala ve ekle

87) Bu iki class kayýt ol ve login ol kýsýmlarýný tamamlayacaklar

88) Github'ta Business/Concrete/UserManager.cs  kopyala sende ekle

89)Github'ta  Business/Concrete/AuthManager.cs kopyala ve ekle

90) AuthManager, bir kayýt olmak için gerekli olan operasyonu yazýyor. KAYIT OLURKEN KULLANICIDAN DTO VE PASSWORD ISTERIZ,
Bunu veritabanýna atabilmek için user nesnesi oluþtururuz. Bunu da ekleriz.

91) Github'ta WebAPI/Controllers/AuthController.cs kopyala ve aynýsýný sende ekle.

92) Business/DependencyResolvers/Autofac/AutofacBusinessModule.cs'de yeni oluþturduðumuz
UserManager, AuthManager gibi yapýlarý tanýtmamýz lazým.

93) Github'ta WebAPI'de Startup.cs 'de var tokenOptions ile bu sistemde jwt kullanýlacak diyoruz.
43-58 arasýný kopyala kendi tarafýnda yapýþtýr.

94) JwtBearerDefaults için WebAPI'de ManageNugetPackages -> Browse -> 
Microsoft.AspNetCore.Authentication.JwtBearer 3.1.12 version install yap

95) Startup'ta app.UseAuthentication(); ekliyoruz middleware denilmekte bunlara.
Neye ihtiyacýmýz varsa onu araya ekliyoruz

96) Öncelikle sisteme bir user ý register eklemeye çalýþalým.

97) Bundan önce Startup'ta cors yapýsýný düzenleyelim. Bu güvenlikle alakalý bir durumdur.
ConfigureService metodunda AddCors ekliyoruz.

98)         services.AddCors(options =>
            {
                options.AddPolicy("AllowOrigin",
                    builder => builder.WithOrigins("http://localhost:4200"));
            });

99) Sonra da middleware lere 
app.UseCors(builder => builder.WithOrigins("http://localhost:4200").AllowAnyHeader());
ekle

100) Register yaptýk sonra login yaparken þifre hatalý demektedir.

101) Böyle bir durumda output'a bakýp nedeni araþtýrabiliriz.
Ya da breakpont ekleyerek bakabiliriz.

102) F11 ile adým adým geçebiliriz breakpoint ten sonra

103) HashingHelper'da bir hata bulduk.

104) User's tablosunda PasswordHash tipini deðiþtirmemiz gerekiyor login'de sorun olmamasý için

CREATE TABLE [dbo].[Users] (
    [Id]           INT          IDENTITY (1, 1) NOT NULL,
    [FirstName]    VARCHAR (50) NOT NULL,
    [LastName]     VARCHAR (50) NOT NULL,
    [Email]        VARCHAR (50) NOT NULL,
    [PasswordHash] VARBINARY (500) NOT NULL,
    [PasswordSalt] VARBINARY (500) NOT NULL,
    [Status]       BIT          NOT NULL,
    PRIMARY KEY CLUSTERED ([Id] ASC)
);

# 15.GÜN DERS NOTLARI

1) Core'da Utilities' IoC folderýnda tüm uygulamalarýmýzý ilgilendiren injection lar için
burada oraya ICoreModule interface i ekle

2) Burada load metotu oluþturalým.

3) Core'da DependencyResolvers folderý ekle ve burada CoreModule classý ekleyelim

4) Bu Class bir ICoreModule clasýý, burada Load'ýn ne yapacaðýný oluþturalým.

5) Startup'ta services.AddDependencyResolvers(); ekle

6) CoreModule gibi baþka modülleri eklemek için yapýyoruz

7) Bunu yapabilmek için IServiceCollection için AddDependencyResolvers extension ný yapmak lazým

8) Core Extension'a ServiceCollectionExtensions class ekle

9) Startup'ta services.AddDependencyResolvers(new ICoreModule[] { 
                new CoreModule()
            } );

10) Register ve login olduktan sonra oluþturulan token ile products eklemeye çalýþtýðýmýzda
yetkiniz yok hatasý alýrýz çünkü ProductManager'da [SecuredOperation("product.add,admin")] yetkisi istiyor

11) Kullanýcýlara claim ler eklememiz gerekiyor

12) OperationClaims'e view data deyip ekleme yapalým

13) UserOperaiotnClaim'de kullanýcýlara claim verelim

14) Cache sistemi yazacaðýz artýk

15) Cache için istediðimiz kadar süre verebiliriz.
Bir ürün güncellenmesi / silinmesinde de cache in uçurulmasý gerekmektedir.

16) Cache lemek istediðimiz data yý key,value olarak tutarýz
ve farklý parametrekere göre de bu yapýyý oluþturacaðýz.

17) Core'da CrossCuttingConcers'ta Caching folderý ekle

18) Caching için .Net'te olan InMemory'i kullanacaðýz

19) Caching'te ICacheManager interface i ekleyelim

20) Bu interface in implementasyonunu yapalým.
Caching'te Microsoft folderý ekle ve bir class oluþtur
MemoryCacheManager.cs

21) Core.DependencyResolvers , CoreModule'da ICacheManager'ýn collection 'ný tanýtmak lazým

22) serviceCollection.AddSingleton<ICacheManager, MemoryCacheManager>();

23) serviceCollection.AddMemoryCache(); bunu da ekle
Bunu yapýnca IMemoryCache _memoryCache; için injection gerçekleþmiþ olur

24) MemoryCacheManager' da bir constructor yapýsý kuaracaðýz

25) using Microsoft.Extensions.DependencyInjection; ekleyelim sonra da

public MemoryCacheManager()
        {
            _memoryCache = ServiceTool.ServiceProvider.GetService<IMemoryCache>();
        }

26) MemoryCacheManager'da RemoveByPattern için Github'ta
Core/CrossCuttingConcerns/Caching/Microsoft/MemoryCacheManager.cs dan koypala ve yapýþtýr

27) _cache yerine _memoryCache yapalým.

28) Sektörde ICacheManager'ý ProductManager da injection yaparlar.
GetAll metodun içinde cache için IsAdd metodunu test eder
Cache te yoksa da git cache ekle diye yapý kurarlar ama bunu her bir metotda yazmak lazým
Onun yerine bir tane Aspect yazarak gerçekleþtireceðiz

29) Bunun için bir tane Aspect yazacaðýz

30) Github'ta Core/Aspects/Autofac/Caching/CacheAspect.cs kopyala

31) Burada metot için bir key oluþturuyoruz varsa onun parametrelerini de alýyoruz
string.Join metoduyla parametrelerin her biri için methot ismi ile parametreleri birleþtiriyoruz
Daha sonra bellekte cache var mý diye kontrol ediyoruz yoksa metotun çalýþmasýný devam ettirip
sonra da cache oluþturuyoruz.

32) Bizde Core -> Aspects -> Autofac -> Caching folderý ekle ve class oluþtur.
Class yerine kopyaladýðýmýzý yapýþtýralým

33) using Microsoft.Extensions.DependencyInjection; ekleyelim sonra da

34) ProductManager'da GetAll ve GetById metodundan önce [CacheAspect] ekleyelim.
CacheAspect.cs 'de if (_cacheManager.IsAdd(key)) için breakpoint ekleyelim
Uygulmamýzý çalýþtýralým ve adým adým takip edelim key ler ve argumanlarýn nasýl geldiðini

35) Her metodun üzerine CacheAspect eklenmez
Çok kullanýlan metotlar için eklenir

36) Github'ta Core/Aspects/Autofac/Caching/CacheRemoveAspect.cs kopyala ve sende ekle

37) CacheRemoveAspect, datamýz deðiþtiði zaman çalýþacak Aspect'tir.

38) using Microsoft.Extensions.DependencyInjection; ekleyelim sonra da

39) ProductManager'da Update öncesinde [CacheRemoveAspect("IProductService.Get")] diyelim
Buradaki mantýk ürünü update ettiðimizde Get içeren tüm keyleri iptal et deriz.

40) Bunu add ve delete de ekleriz.

41) IProductService'de IResult AddTransactionalTest(Product product); ekleyelim.
Transaction'ý uygulamalarda tutarlýlýk olmasý için uygularýz.
Ayný süreçte iki tane veritabaný iþi olduðu zamanki durumlarda kullanýrýz.

42) ProductManager'da bu metotu implemet edelim.

43) Bu metotdan önce bir transactionaspect yapacaðýz

44) Github'ta Core/Aspects/Autofac/Transaction/TransactionScopeAspect.cs  kopyala
ve uygulamamýzda yapýþtýralým.

45) Sistemimizin performans durumuna bakmak için de Performance aspect yapýsý kuracaðýz

46) Core.DependencyResolvers CoreModule'a ;
services.AddSingleton<Stopwatch>(); ekleyelim.

47) Github'ta Core/Aspects/Autofac/Performance/PerformanceAspect.cs kopyala ekle

48) using Microsoft.Extensions.DependencyInjection; ekleyelim sonra 

49) ProductManager'da GetById metodundan önce [PerformanceAspect(5)] ekleyelim
Bu metodun çalýþmasý 5 saniyeyi geçerse uyar diyoruz

# 16. GÜN DERS NOTLARI

1) Node.js => javascript kodlarýnýn Back-end de çalýþtýrmasýna da yarar ama biz ;

Node npm ve test ortamý için LifeServer imkaný saðlamar biz bu amaçlar için kullanacaðýz

2) Visual Studio Code'u açalým.

3) angular.io/cli adresine gidelim. Burada aþaðýdaki kodu kopyalayalým
npm install -g @angular/cli

4) angular daki bileþenleri hýzlýca sisteme dahil etmek için 

5) VS Code Terminal -> New Terminal -> Comment Promt deyip aþaðýda + ya basalým

6) Kopyaladýðýmýzý terminal de yapýþtýralým

7) burada npm paketlerini global olarak kuruyoruz bir daha angular projelerinde node bu paketleri artýk
tanýyor olacaktýr

8) C dizininde kamp-frontend folderý ekle

9) Terminalde cd.. cd.. deyip cd kamp-frontend e gidelim

10) ng new northwind diyelim ve y diyelim

11) Angular'da Routing(sayfalar arasý gezinti) denilen bir durum için de y diyelim

12) CSS içinde Enter yapalým

13) cd northwind yapalým Terminal'de

14) code . dediðimiz zaman ilgili klasoru visual studio code ' da aç demektir

15) ng serve = node u kullanarak yayýna al
ng serve --open bir tarayýcý da aç

16) ng serve --open --port 4201 deyip bu port ta yayýnla diyebiliriz

17) Angular, React => SPA yani tek sayfalýk uygulamalardýr

18) node_modules klasoru tüm angular paketlerimizi içeren klasordur

19) Baþkasýnýn angular projesini almak için npm install yazýlýr

20) Bu paketlerin ne olduðunu da package.json dosyasýnda bilinir

21) burada dependencies paketleri kullanýcýnýn göreceði uygulamalar için
Devdependencies ise yazýlým geliþtiricisinin kullanacaðý uygulamalar için paketlerdir

22) src klasoru projemizin kaynak kodlarýný içeren klasordur

23) src -> app klasorunde uygulama kodlarýmýz yer alýr

24) index.html'te <app-root> tag i var bu angular tarafýndan tanýlan bir component

25) app klasorunde sað týkla new folder de ve components adýný ver

26) app.component.ts bizim componentimizdir(datayý yönettiðimiz yer) ve app.component.html'de bizim page tarafýmýzdýr bunlar birbiryle baðlantýlýdýr

27) app.component.html'de <router-outlet></router-outlet> dýþýndakileri silelim File -> Save all diyelim

28) Terminal de Control+C dediðimizde yayýný durdururuz

29) Angular, React vb. frameworkler ile dinamik bir yapý kuruyoruz çünkü veri tabanýndan verilerimizi alacaðýz Restful servise baðlanýp yapacaðýz

30) Bu datayla ilgili kýsýmlarý da app.component.ts'de yöneteceðiz.

31) @Component deyince AppComponent'te sen bir componentsin deriz ve templateUrl ile hangi sayfanýn componenti olduðunu belirtiriz

32) index.html'deki app-root tag i @Component'deki selector den gelmektedir. 

33) styleUrls'te css'lerin olduðu yer bu [] arasýnda yazýlýr ve array demektir.

34) title:string veri tipi tanýmlama

35) component teki title ý sayfaya getimek için html de {{title}} dememiz yeterli olacaktýr.

36) product:any demek product her veri türünden olabilir demektir.

37) Javascript küçük büyük harf duyarlýdýr.

38) *ngFor Angular için Directive yapýsýdýr. Ýlgili html elementini manipule etmemize yarar. Burada ngFor ile tekrarlama kuralý kuracaðýz.
Ürünümüz kadar li tag i çalýþsýn

39) <li *ngFor="let product of products"></li> bildiðimiz foreach yapýsýdýr

40) app new folder directives adýný ver

41) burada kendi directive lerimizi yapmak için

42) ngFor da bir directive dir

43) Artýk componentlerimizi oluþturacaðýz. Folder'da sað click Open in Terminal Integrated diyelim

44) Terminal de ng g component product = g burada generate demek  yani angular kodumuzu product adýyla component oluþtur demektir

45) ng g component category yapalým bir de ng g component navi(sayfamýzdaki navigate bar için) yapalým

46) Module birbiriyle iliþkin bileþenleri topladýðýmýz yerdir.

47) app.module.ts 'de bizim eklediðimiz componentler burada otomatik olarak eklenir.

48) index.html'de component  hiyerarþisi düzenlenir.

49) Component leri nasýl kullanýyoruz ona bakalým app.component.html'de daha önce yazdýðýmýz kodlarý ctrl+K ctrl+C ile comment yapalým

50) product component imizin selectoru app-product olarak otomatik düzenlenir bunu burada çaðýrýrýz

51) 
<app-navi></app-navi>
<app-category></app-category>
<app-product></app-product>

52) getbootstrap.com twitter tarafýndan geliþtirilmiþ css geliþtirme tool kiti (get started diyip inceleyebiliriz)

53) Burada components larda navbar a bakalým onun örnek kodunu kopyalayalým

54) navi de navi.component.html'de herþeyi sil ve bu kodu yaðýþtýralým

55) bunu yaptýðýmýzda node.module'da da bununla ilgili yapýlarýn kurulmasý lazým oyüzden terminal de
npm install bootstrap yapalým

56) Bu css'i bizim sayfamýzda çalýþtýrmak için angular.json dosyamýza gidelim.

57) styles'ta uygulamamýzda geçerli olacak styles leri tanýtacaðýz

58) "./node_modules/bootstrap/dist/css/bootstrap.min.css"

59) yeni bir paket yüklediðimizde terminaldaki node çalýþmasýný durdurup bir daha yayýna almak lazým çünkü bootstrap paketini install yapmýþtýk

60) app.component.ts'de product tanýmlamasý yaptýðýmýz kodlarý keselim component te product ta product.component.ts dosyasýna yapýþtýralým 10 satýra

61) product.component.html de bir table oluþturalým

62) <table class="table">
  <tr *ngFor="let product of products">
    <td>{{product.productId}}</td>
    <td>{{product.productName}}</td>
    <td>{{product.categoryId}}</td>
    <td>{{product.unitPrice}}</td>
  </tr>
</table>

63) Extensions'a týklayýp arama çubuðuna bracket pair colorizer ve prettier-code formatter install yapalým

# 17. GÜN DERS NOTLARI

1) getbootstrap.com'daki version v5.0.0-beta3 versiyonunu kopyalayýp terminalde cmd npm install bootstrap@v5.0.0-beta3 yazalým

2) app.component.html de bir div tag i ekleyelim app ile baþlayan tag leri de bu div in içinde çaðýralým

3) Sayfamýzda navbar ýn altýnda solda kategoriler saðda ürünler olsun istiyoruz. Bunun için row mantýðýný kullanacaðýz

4) Yukarda oluþturduðumuz div içersinde yeni div class="row" css clasý ý ile bunu gerçekleþtirelim.Diðer iki app tagi için iki tane div tanýmlayalým bu sayfayý 12 eþit parçaya böler

5) Kategoriler olan bölüm 12'nin 3 ünü kapsasýn, ürünler 9 parçayý kapsasýn. Bunun için div class="col-md-3" ve div class="col-md-9" olarak tanýmlayalým.

6) https://www.creative-tim.com/ sitesinde angular için ücretsiz yapýlar bulunmakta.

7) getbootstrap.com da kategorileri listelemek için list gruptaki kodu kopyalayalým

8) Bu kodu category compenet hmtl ine yapýþtýralým.

9) Bir front-end api'den gelen datayý çok iyi yorumlamak gerekir. Ýlk olarak bu api bize ne döndürüyor onu tespit etmemiz gerekir.

10) Biz projemizdeki products larý karþýlamak için nesne tanýmlamamýz gerekir.
Buna ClientModule diyoruz. app de new folder diyip models klasoru oluþturalým.

11) Burada product.ts adýyla file oluþturalým. Burada product için interface oluþturacðýz.Buradaki durum biraz daha sýnýrlandýrma iþlemleri tanýmlanýyor.

12) Burada interface adlarýnýn önüne I harfini eklemiyoruz.

13) product component ts de artýk product nesnesine sen bir Product arrayi sin diyebiliriz.

14) models klasorunde productResponseModel.ts file ý ekleyelim.

15) Gelecek datayý karþýlayacak model oluþturuyoruz.

16) models klasorunde responseModel.ts file ý ekleyelim. Burada productResponseModel'deki tanýmlamalarý burada yapacaðýz artýk tekrarlamamak için diðer durumlarda

17) ProductResponseModel'e extends deyip ResponseModel yapabiliriz

18) Ayný iþlemleri category içinde yapalým

19) ResponseModel bizim temelimiz success ve message tutan nesnemiz; diðer nesnelerimizde bunu inhert ediyoruz.

20) ProductComponent OnInit implementi ettiðimiz için ngOnInit'in yazýlmasý gerekir. Bu compenent açýldýðýnda çalýþan kod parçacýðýdýr.

ngOnInit(): void {
    console.log("Init çalýþtý.")
  } yazdýðýmýzda bworser da F12 yaptýðýmýzda console sekmesinde Init çalýþtý çýktýsýný görürüz.

21) Þimdi product larý almak için component te metot yazmaya baþlayalým.

22) javascript te normalde void yok bunu ts yapar

23) Api ye baðlanabilmek için httpClient nesnesi vasýtasýyla bunu kurabiliyoruz.

24) product.component.ts de import {HttpClient} from '@angular/common/http
HttpClient'ý kullanabilmek için constructor da bunu implement etmemiz lazým.

25) getProducts(){
    this.httpClient.get<ProductResponseModel>(this.apiUrl)
  }

  gelen datayý ProductResponseModel ile map eder.

26) apiUrl bizim get kýsmýmýzdan gelen url

27) Sonra bunu subscribe ile abone olalým diyoruz. Gelen yanýtý response atýyoruz.

28) ngOnInit metounda artýk getProducts metodunu çaðýrabiliriz.

29) Backend'de Autofac te belirttiðimiz gibi burada da HttpClient ý tanýtmamýz lazým

30) app klasorunde app.module.ts'de declarations'ta bunu eklememiz lazým

31) Bu yüzden önce import {HttpClientModule} from '@angular/common/http' eklemek lazým.
Bunu da imports ta eklemek lazým. Çünkü bunu biz yazmadýk dýþardan alýyoruz.

32) Eðer bir api den istek yapmaya çalýþtýðýmýzda CORS hatasý alýrsak backend tarafýnda api'ye eriþebilmek için gerekli configuration yapýlmamýþ demektir.

33) Startup.cs'de 
services.AddCors(options =>
            {
                options.AddPolicy("AllowOrigin",
                    builder => builder.WithOrigins("http://localhost:4200"));
            }); yoksa ekleyelim

34) prdocut.compononet.html'de bir baþlýk verelim bunu thead taginin için tr ve th ile yaparýz

35) Burada datamýzýn tablo çýktýsýnda sayfamýzda tablo kolonlarýna baþlýk vermemizi saðlamaktadýr.

36) getProducts için yaptýðýmýz metotta her bir component için tekrarlamak yerine Angular'da bu yapýlarý Service mimarisiyle backkend deki gibi yapacaðýz.

37) app de services klasoru ekleyelim.

38) Bu klasore terminalde yerleþmek için sað clik open in integrated terminal diyelim.

39) Terminalde ng g service product diyelim bize product service oluþturacak

40) Angular'da @Injuctable yapýsý servis kullanýldýðýný gösterir.

41) product.component.ts de private httpClient: HttpClient yapýsýný keselim product.service.ts'deki constructor a yapýþtýralým

42) getProducts metodunu da kopyalayým ve product.service.ts ye yapýþtýralým.

43) Gerekli import larý burada da tanýmlayalým ve diðer taraftaki apiUrl i burada constructordan önce tanýmlayalým

44) product.service.ts'de 
getProducts() {
    this.httpClient.get<ProductResponseModel>(this.apiUrl);
  }
  olarak tanýmlarýz. Bu bir Observable döndürüyor.
45) Dolayýsýyla bu metodu artýk Observable deðer döndüren bir metot olarak tanýmlayabiliriz
getProducts():Observable<ProductResponseModel> {
    return this.httpClient.get<ProductResponseModel>(this.apiUrl);
  }

46) product.component.ts'de constructor ýn içinde artýk ProductService i inject yapabiliriz.

47) Bir service i kullanabilmek için bu hareketi yapmamýz gerekir.

constructor(private productService:ProductService) {}

48) product.component.ts'de getProducts metodunu artýk subscribe yapabiliriz.

49) Back-end asekron çalýþtýðý için burada subscribe yapýsý kullanýlýr.

50) subscribe yapýsý asekronda iþlerin sýrayla yapýlmasýný saðlamaktadýr çok önemli

51) getbootstrap.com da spinner dan bir spin alalým.

52) prodcut.component.html de table dan önce spinner kodunu yapýþtýralým

53) Ancak bu spinner iþlemini data yüklü deðilse yapmasýný istiyoruz onun içinde ngIf yapýsýný kullanýyoruz.

54) <div *ngIf="dataLoaded==false" class="spinner-border text-primary" role="status">
  <span class="visually-hidden">Loading...</span>

55) Bu spinner ý daha rahat görmek için backend de controller da getall metotunda 
Thread.Sleep(5000); yapalým.

56) Tablodaki kolon adlarý da veri yüklendikten sonra gelsin diyebiliriz ayný þekilde if yapýsýyla


#18.GÜN DERS NOTLARI

1) models da category ve product için bir ResponseModel inherit ediyorduk bunu refactor edeceðiz.

2) models da listResponseModel.ts file oluþturalým.

3) 
export interface ListResponseModel<T>{
  data:T[];
}

4) T yerine hangi nesneyi verirsek artýk data o olacaktýr.

5) Bizim artýk categoryResponseModule ve productResponseModele a ihtiyacýmýz yok onlarý silelim.

6) product.service.ts'de artýk yeni list modulemuzu import ve constructor da injection yapmalýyýz.

7) product.component.ts'de productresponsemodel importunu silelim.

8) Ürünleri listelediðimiz gibi kategorileri de listeleyeceðiz.

9) Bunu category.componenet.ts'de bir categories arrayi oluþturmalýyýz.

10) Product için yazdýðýmýz service category içinde yazacaðýz

11) services klasorunda sað clik open in integrated terminal deyip ng g service category

12) spec.ts dosyalarý unit test yapmak içindir onlarý silebiliriz.

13) service lerde de bir url alýrýz httpClient'i injection yaparýz , Product yerine Category ekleriz dolayýsýyla burasý da refactor edilebilir.

14) category.service.ts

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { Category } from '../models/category';
import { ListResponseModel } from '../models/ListResponseModel';

@Injectable({
  providedIn: 'root'
})
export class CategoryService {

  apiUrl = 'https://localhost:44389/api/categories/getall';
  constructor(private httpClient: HttpClient) { }

  getCategories():Observable<ListResponseModel<Category>> {
    return this.httpClient.get<ListResponseModel<Category>>(this.apiUrl);
  }
}

15) Backend 'de category için controller eklememiz lazým.

16) CategoriesController'da bir ICategoryService injection yapýldýðý için AutofacBusinessModule'da bu service in tanýtýlmasý gerekmektedir. Bunu kontrol etmek gerekir.

17) models'de listResponseModel.ts'de extends ResponseModels yapmamýz lazým success ve message bilgileri de api den geldiði için.

18) Artýk category verilerimize eriþebiliyoruz þimdi componenet yapýsýnda verilerimizin gösterimiyle ilgileneceðiz. Bu veritabanýnda gelen verinin yönetimini componenet.ts'de tasarlayalým.

19) category.componenet.ts

import { Component, OnInit } from '@angular/core';
import { Category } from 'src/app/models/category';
import { CategoryService } from 'src/app/services/category.service';

@Component({
  selector: 'app-category',
  templateUrl: './category.component.html',
  styleUrls: ['./category.component.css']
})
export class CategoryComponent implements OnInit {

  categories : Category[]=[];
  constructor(private categoryService:CategoryService) { }

  ngOnInit(): void {
    this.getCategories();
  }

  getCategories() {
    this.categoryService.getCategories().subscribe(response=> {
      this.categories=response.data
      //this.dataLoaded=true;
    })
  }

}


20) Artýk bunun html'ini de yazabiliriz.

21) category.componenet.html'de li leri tekrarlamamýz gerekecektir.

<ul class="list-group">
  <li *ngFor="let category of categories" class="list-group-item">{{category.categoryName}}</li>
</ul>

22) Bundan sonraki adýmda category menüsünde herhangi bir kategori seçildiðinde ürün listesi o kategorideki ürünler gelmesi üzerine yoðunlaþýcaz. Bu konu Angular Rooting kapsamýnda deðerlendirilmektedir.

23) src -> app -> app.componenet.html'deki router-outlet'i kesip app-product olan yer yerine yapýþtýralým.

24) Bu router yapýsýný app-routing.module.ts'de düzenlenir.

25) 
const routes: Routes = [
  {path:"", pathMatch:"full", component:ProductComponent},
  {path:"products", component:ProductComponent}
];

26) Burada pathMatch'i path'te hiç bir þey ilk etapta vermediði için anasayfamýzý göstermek için kullanýlýyor.

27) Þimdi artýk kategoriye göre filtreleme yapmak istiyoruz.

28) category.componenet.html'de aslýnda bir týklama iþlemi yapmak istiyoruz. Bunun için
<ul class="list-group">
  <li (click) = "setCurrentCategory(category)" *ngFor="let category of categories" class="list-group-item">{{category.categoryName}}</li>
</ul>

29)  category.componenet.ts'de setCurrentCategory fonksiyonun yazalým
setCurrentCategory(category:Category) {
    console.log(category.categoryName)
  }

30) Html'de console'da kategorilere týkladýktan sonra kategori isimleri geliyor. Þimdi ts'de bu kategoriler ile iþlem yapabilmek için kod yazalým.

31) Önce ts.config.json'da strict'ten sonra "strictPropertyInitialization": false, eklersek herhangi bir nesneyi yeni bir objeye atarken new lemek zorunda kalmayýz.

32) category.componene.ts'de currentCategory'i tutmak için düzenleme yapýyoruz ve setCurrentCategory'de bu yapýyý kullanýyoruz.

33) Angular öncelikle html yapýsýný çalýþtýrýr sonra verilerinizi getirecektir. Uygulamayý ilk kez çalýþtýrdýðýmýzda henüz bir kategoriye týklamadýðýmýz için kategori tablosu ilk önce boþ gelir týkladýðýmýzda verileri getirir.

34) Burada Angular'a eðerki bu kategori dolu deðilse bunu render etme.

34) Bunun için html'de 
<ul class="list-group">
  <li (click) = "setCurrentCategory(category)" *ngFor="let category of categories"
   class="list-group-item">{{category.categoryName}}</li>
</ul>

<h5 *ngIf="currentCategory">{{currentCategory.categoryName}} seçtiniz</h5>
yapýsýný kullanýrýz.

35) Seçtiðimiz kategorileri tabloda seçildiðinin belirgin olmasýný istiyoruz ve onu seçtiðim zaman css'i ni deðiþtirmek te istiyoruz. Bunu li tag in de class="list-group-item active" yapýsý ile kurarýz ama bunu bütün kategori tablosu için aktive yapar biz hangi kategori seçildiyse onun için yapmak istiyoruz.

36) Bunun için componenet'te bir metod yazabiliriz.
getCurrentCategoryClass(category:Category) {
    if(category == this.currentCategory) {
      return "list-group-item active"
    }else{
      return "list-group-item"
    }
  }

37) html'de li tag indeki class bir metod kullanacaðý için bu class 'ý köþeli parantez içerisinde yazmamýz gerekir.

38) 
<ul class="list-group">
  <li (click) = "setCurrentCategory(category)" *ngFor="let category of categories"
   [class]="getCurrentCategoryClass(category)">{{category.categoryName}}</li>
</ul>

<h5 *ngIf="currentCategory">{{currentCategory.categoryName}} seçtiniz</h5>

39) Þu anda kategoride týkladýðým zaman hangi kategoriye týkladýðýmý görebiliyorum þimdi ise bu kategori için veriyi getirmesini isteyeceðiz.

40) Bunun için routerLink yapýsý devreye girecektir. 
<ul class="list-group">
  <li
    (click)="setCurrentCategory(category)"
    routerLink = "/products/category/{{category.categoryId}}"
    *ngFor="let category of categories"
    [class]="getCurrentCategoryClass(category)"
  >
    {{ category.categoryName }}
  </li>
</ul>

<h5 *ngIf="currentCategory">{{ currentCategory.categoryName }} seçtiniz</h5>

41) Artýk bu routerLink'leri tanýmlayacak yapýlarý kurmamýz gerekmektedir.

42) Bizim burada prodoct componenet'i ne bir kategori parametresi göndermemiz gerekir.

43) Bu rout configurasyonun app-routing.module.ts'de yapýyorduk;
const routes: Routes = [
  {path:"", pathMatch:"full", component:ProductComponent},
  {path:"products", component:ProductComponent},
  {path:"products/category/:categoryId", component:ProductComponent}
];

44) Backend tarafýnda kategori'ye göre ProductsController'da bir metot yazmamýþtýk o yapýyý oluþturmamýz gerekmektedir.

45) Controller'dan baþlayarak bütün katmanlarý sýrasýyla oluþturacaðýz.(Eðer manager'da öyle bir metot yoksa)

46) product.component.ts'de getProducts metodunda product service tarafýnda tanýmlanan getProducts metotu çalýþmakta ama biz eðer bir kategori seçilmiþse getbycategory gibi bir metot çalýþsýn seçilmemiþ default olarak getProducts çalýþsýn demeliyiz.

47) Burada service yapýsýnda apiUrl'i daha önce vermiþtik bizim api yapýmýzdan kaynaklý oluþturulan url'ler zaten api kýsmýna kadar standart api den sonra her sayfanýn url'i deðiþmektedir.

48) Bir fonksiyon içerisinde deðiþken yaratmak için let keyword'unden yararlanýrýz.

49) product.service.ts deki apiUrl kýsmýný düzenliyoruz;

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { ListResponseModel } from '../models/ListResponseModel';
import { Product } from '../models/product';

@Injectable({
  providedIn: 'root'
})
export class ProductService {

  apiUrl = 'https://localhost:44389/api/';
  constructor(private httpClient: HttpClient) { }

  getProducts():Observable<ListResponseModel<Product>> {
    let newPath = this.apiUrl + "products/getall"
    return this.httpClient.get<ListResponseModel<Product>>(newPath);
  }

  getProductsByCategory(categoryId:number):Observable<ListResponseModel<Product>> {
    let newPath = this.apiUrl + "products/getbycategory?categoryId="+categoryId
    return this.httpClient.get<ListResponseModel<Product>>(newPath);
  }
}

50) product.componenet.ts'de bir parametreyi okumak için constructor da activatedRoute yapýsýný injecte etmemiz gerekir.

51) activatedRoute bizim browser'ýmýzda güncel url'i alýr ve biz kategorilere týkladýðýmýzda url'de kategori Id'sine göre deðiþmektedir.

52) Bu url'lerde idleri okuyacaðýz.

53) Öncelikle products.componene.ts'de service te oluþturduðumuz GetProductsByCategory için veriyi subscribe yapacak metodumuzu yazalým.

54) Sonrada url'de kategori id doluysa bu metodu çalýþtýr yoksa getProducts'ý çalýþtýr diyeceðiz.

55) Bunu ngOnit'de yapacaðýz. 

import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Product } from 'src/app/models/product';
import { ProductService } from 'src/app/services/product.service';

@Component({
  selector: 'app-product',
  templateUrl: './product.component.html',
  styleUrls: ['./product.component.css'],
})
export class ProductComponent implements OnInit {
  products: Product[] = [];
  dataLoaded = false;

  // productResponseModel:ProductResponseModel={
  //   data : this.products,
  //   message:"",
  //   success:true
  // };

  constructor(private productService:ProductService, private activatedRoute:ActivatedRoute) {}

  ngOnInit(): void {
    this.activatedRoute.params.subscribe(params => {
      if(params["categoryId"]) {
        this.getProductsByCategory(params["categoryId"])
      }else{
        this.getProducts()
      }
    })
  }

  getProducts() {
    this.productService.getProducts().subscribe(response=> {
      this.products=response.data
      this.dataLoaded=true;
    })
  }

  getProductsByCategory(categoryId:number) {
    this.productService.getProductsByCategory(categoryId).subscribe(response=> {
      this.products=response.data
      this.dataLoaded=true;
    })
  }
}

56) Artýk kategori ye týkladýðýmýzda ona göre ürün getirmeye baþlayacak ama tekrardan ürünlerin hepsini listelemek istersek category html'de ul tag inde en üstte bir tane daha li tagi açabiliriz.

57) category html'i

<ul class="list-group">
  <li [class]="getAllCategoryClass()"
      routerLink="/products">
    Tüm Ürünler
  </li>
  <li
    (click)="setCurrentCategory(category)"
    routerLink = "/products/category/{{category.categoryId}}"
    *ngFor="let category of categories"
    [class]="getCurrentCategoryClass(category)"
  >
    {{ category.categoryName }}
  </li>
</ul>

<h5 *ngIf="currentCategory">{{ currentCategory.categoryName }} seçtiniz</h5>


58) Tüm ürünler için getAllCategoryClass metodunu class içerisinde çaðýrdýk bu metot herhangi bir kategori seçili deðilse tüm tabloyu active edecektir. Bunu da componen.ts'de tanýmlýyoruz;

getAllCategoryClass(){
    if(!this.currentCategory) {
      return "list-group-item active"
    }else {
      return "list-group-item"
    }
  }

59) Nivbar'da dropdown sekmesi çalýþmýyor þu anda onun sebebi JQuery paketinden kaynaklanmaktadýr. npm install jquery

60) Bunun devreye girebilmesi için angular.json'da scripts array'ini aþaüýdaki gibi düzenleyelim;

"scripts": [
              "./node_modules/jquery/dist/jquery.min.js",
              "./node_modules/bootstrap/dist/js/bootstrap.min.js"
            ]

61) Resim eklemek için Startup.cs ' de app.UseStaticFiles(); eklemek lazým yoksa image path'ini localhost ile eþleþtiremez.

62) Angular'da app-rotuing-module'da bir path tanýmladýðýnýzda parametre verdiðiniz alan neyse örneðin :carId , :ýd vb. ise veri tabanýnýzdaki

controller ve class alanlarýnýz ile Angular'daki modules klasorundeki nesnelerinizdeki alan adlarýnýn uyuþmasý lazým yoksa cannot match url hatasý alýrýz.


#19.GÜN DERS NOTLARI

1) Bugünkü konumuz pipe üzerine olacak.

2) pipe, elimizde bir data var ve o data yý farklý bir þekilde göstermek istiyorsak kullanýyoruz. Bu angular'da built-in olarak gelen pipe lar mevcut ama kýsýtlý.

3) Biz kendi pipe'larýmýzý yazacaðýz.

4) src-app-> pipes klasoru ekle

5) pipes open in integrated terminal deyip ng g pipe vatAdded bunu kdvekleme için yapacaðýz.
pipe'larý componenet'teki veriyi gösterirken html'de yararlanmalýyýz.

6) componenets klasorunde product -> html'de 

<td>{{product.productName | uppercase}}</td>
lowecase'de deneyebiliriz

7) unitPrice'a ek olarak bir kolon daha ekleyip KDV'li fiyatý da göstermek isteyelim.

8) Elimizdeki fiyatak Kdv oraný uygulayarak bunu yapabiliriz.Bunu oluþturdupumuz vatAdded pipe ile yapacaðýz.

9) <td>{{product.unitPrice | vatAdded:10 | currency}}</td>
ile kdv oraný için 10 parametresi veriyoruz.
currency'de para birimi eklemek için hazýr pipe'lardan birisi

10) pipe'ta transform metodumuzu güncellemeye baþlýyoruz.

11) transform(value: number, rate: number): number {
    return value + (value*rate/100);
  }

12) Yeni bir pipe örneði daha yapalým.

13) getbootstrap'te forms form control ile bir pipe yapýsýyla filtreleme yapacaðýz oradan
ilk div yapýsýný kopyalayalým

14) 
<div class="mb-3">
  <label for="exampleFormControlInput1" class="form-label">Email address</label>
  <input type="email" class="form-control" id="exampleFormControlInput1" placeholder="name@example.com">
</div>

15) prdocut html'de table tag ten önce ekleylim bu kodu

16) 
<div class="mb-3">
  <label for="filterText" class="form-label">Ürün ara</label>
  <input type="text" class="form-control" id="filterText" placeholder="arama ifadesi giriniz">
</div>

17) Kullanýcýnýn bir inputa girdiði bilgiyi nasýl alýrým bunu önce componenet'te tanýmlamalýyým.

18) componenet'te filterText=""; tanýmlýyoruz. Bunuda html'de [(ngModel)]="filterText" ile bu input'un id'sinden gelecek açýklamayla map et deriz.

<input type="text" [(ngModel)]="filterText" class="form-control" id="filterText" placeholder="arama ifadesi giriniz">

19) html'de bir div daha ekleyelim input'ta yazýlaný çekip yazdýrmayý teyit etmek için ama bir hata alacaðýz

<div>
  {{filterText}} aradýnýz
</div>

20) Bu hata ngModel'i bilemedim diyor Angular bunun için Angular'da formlarla çalýþýrken bir input ile çalýþýrken app.module.ts'de bir modülü import etmek lazým.

import{FormsModule} from "@angular/forms" ve bu FormsModule'da imports'ta belirtelim.

21) Þimdi div yapýsýný güzelleþtirelim.

<div *ngIf="filterText" class ="alert alert-success">
  {{filterText}} aradýnýz
</div>

22) Bir arama cümlesi girildiyse alerti göster diyoruz kýsaca.

23) Þimdi bu aranan kelimeye göre ürün listelemek için pipe yazalým.

24) ng g pipe filterPipe yapalým ama dizine dikkat et pipes klasorundeyken yapýlmalý

25) Bu pipe'ýn transform metodu aþaðýdaki gibi;

burada return'de map,filter gibi javascript komutlarý yazacaðýz.

26) Öncelikle gelen filter text'i ya küçük ya da büyük harfe çevirelim.

filterText varsa küçük harfe çevirelim;
filterText = filterText?filterText.toLocaleLowerCase():""

buradaki soru iþareti var mý yok mu diye bakýyor.

27) 
  transform(value: Product[], filterText: string): Product[] {
    filterText = filterText?filterText.toLocaleLowerCase():""
    //Product'ta gelenfilterText'i dolaþ foreach ile veritabanýndan gelen ürün isimlerini de küçük harf yaptýktan sonra
    //indexOf ile filterText veritabanýndan gelen ürün isimleriyle eþleþiyor mu
    //eþleþmeyi de !==-1 ile eðer -1'den farklýysa yani eþleþiyorsa bunu bir array olarak döndürür
    //eþleþen veri yoksa value yu döndür
    return filterText?value
    .filter((p:Product)=>p.productName.toLocaleLowerCase().indexOf(filterText)!==-1)
    :value;
  }

28) Bunu html'de kullanmak için products'ý for ile döndürdüðümüz tr'de uygulamamýz lazým.

29) <tr *ngFor="let product of products | filterPipe:filterText ">

30) indexOf bir array döndürür bize unutmayalým.

31) Herhangi bir ürünü sepete ekleme özelliði üzerine çalýþacaðýz bundan sonraki adýmlarda

32) Her ürünün yanýna buton ekleyelim.

<table *ngIf="dataLoaded==true"  class="table">
  <thead>
    <tr>
      <th>Id</th>
      <th>Ürün Adý</th>
      <th>Kategori</th>
      <th>Fiyat</th>
      <th>Kdv'li Fiyat</th>
      <th>Stok Adedi</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
  <tr *ngFor="let product of products | filterPipe:filterText ">
    <td>{{product.productId}}</td>
    <td>{{product.productName | uppercase}}</td>
    <td>{{product.categoryId}}</td>
    <td>{{product.unitPrice}}</td>
    <td>{{product.unitPrice | vatAdded:18 | currency}}</td>
    <td>{{product.unitsInStock}}</td>
    <td><button type="button" class="btn btn-success"> Sepete ekle</button></td>
  </tr>
</tbody>
</table>

33) Þimdi button'da click olduðunda componenet'teki addToCart() fonksiyonu çalýþssýn diyelim
button (click)="addToCart(product)"

34) product.component.ts'de bu metodu tanýmlayalým

addToCart(product:Product) {
    console.log(product)
  }

35) Sepete eklendiðinde bir notification sistemi ekleyelim.

npm install ngx-toastr

bu yapýyla kullanýcýlarý yönlendirmek için kullandýðýmýz notificationlarý yönlendirmek için

36) ngx-toastr Angularýn animasyon paketini kullanýyor onu da yüklemek için

npm install @angular/animations

37) angular.json'da bu ngx-toastr'daki css'i eklemeliyiz.

"./node_modules/ngx-toastr/toastr.css", styles'a ekleyelim.

38) app.module.ts'de de eklediðimiz installer için import yapmalýyýz
import{ToastrModule} from "ngx-toastr" ve import's ta ToastrModule.forRoot({
      positionClass:"toast-bottom-right"
    }) eklemeyi unutma

39) Bu notification'ýný sepete eklediðimizde çýkartacaðýz

40) Bu toastr bir service olarak yazýldýðý için bunu product component'ýnda constructor 'da injection yapmalýyýz

constructor(private productService:ProductService,
    private toastrService:ToastrService,
    private activatedRoute:ActivatedRoute) {}

41) Bu injectione da artýk addToCart'ta kullanabiliriz.

addToCart(product:Product) {
    this.toastrService.success("Sepete eklendi",product.productName);
  }

42) Yeni bir þey install yapýtðýmýzda çalýþmayý durdurup tekrar bir açalým Angular ozaman daha iyi derliyor.

43) Animasyonumuzun daha iyi görünmesi için eklediðimiz bir install daha vardý onu da app module da import edelim.

44)
import {BrowserAnimationsModule} from "@angular/platform-browser/animations"

45) Buttona týkladýðýmýzda Sepete ekle iþlemi veritabanýndaki tablolarýmýza da iþlesin istiyoruz.

46) Bunun için Back-end tarafýnda iþlemleri gerçekleþtirmemiz gerekmektedir. Buna alternatif olarakta bunu front-end tarafýnda yapalým þimdilik.

47) Angular'da ilk önce bunun model'ini models klasorunda cartItem.ts olarak oluþturalým.

48) Biz bu bilgileri veritabanýnda deðil bellekte tutacaðýz.

49) models'da cartItems.ts oluþturalým

50) Sepete eklenen ürünleri Dropdown'da göstermek istiyoruz.

51) Böyle bir durumda bunu nav içinde de yapabiliriz ama bunun için bir component oluþturarak yapalým.

52) componenets klasorunu open in integrated terminal yapýp
ng g component cart-summary

53) navi html'de dropdown kýsmýný bululalým. 15 ile 25. satýrlarý keselim. Onun yerine app-cart-summary tag'i ekleyelim.

54) Çünkü bunu cart-summary componenet'ýnda tanýmlayacaðýz.

55) cart-summary html'de kestiðimiz kodlarý yapýþtýralým. 

56) Artýk burada cartItems elemanlarýný bir döngüyle buraya ekletebiliriz.

57) cart-summary componenet.ts'de cartItems array'i tanýmlayalým.
Html kýsmýnda da bazý düzenlemeler yapýyoruz.

58) 
<li *ngIf="cartItems" class="nav-item dropdown">
  <a class="nav-link dropdown-toggle" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Sepetiniz
  </a>
  <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
    <li *ngFor="let cartItem of cartItems"><a
       class="dropdown-item" >{{cartItem.product.productName}}</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><a class="dropdown-item" >Sepete git</a></li>
  </ul>
</li>

59) Þimdi sepettimiz boþ olduðu için Sepete ekle butonuna basýldýðýnda sepet bilgilerim eklensin istiyoruz. Bunu farklý ortamlarda da kullanacaðýmýz için bir service yapýsý kurmalýyýz.

60) ng g service cart (tabi service folderýna pathi sabitledikten sonra)

61) cart service.ts ' de burada ekleme iþlemlerini tanýmlayacaðýz.
Ayný ürünü birden fazla eklediðimizde quantity'sini arttýrmak lazým

62) Javascript'te arraye eleman eklemek için push fonksiyonu kullanýlýr.

63) 
  addToCart(product:Product){
    //sepete eklenen product bizim sepete ekleme iþlemi için tutlan array'imizde olanlarýn itemý
    let item = CartItems.find(c=> c.product.productId === product.productId);
    if(item){
      item.quantity+=1;
    }else{
      let cartItem = new CartItem();
      cartItem.product=product;
      cartItem.quantity=1;
      CartItems.push(cartItem)
    }
  }

64) Bundan sonra sepeti de çekmemiz gerekecekir.

  list():CartItem[]{
    return CartItems;
  }

65) Bu service product componenet'inde kullanacaðýz bunu da constructor'da belirtelim

66) Burada addToCart metodu yazmýþtýk oraya artýk CartService'deki metodumuzu çaðýrabiliriz

  addToCart(product:Product) {
    this.toastrService.success("Sepete eklendi",product.productName);
    this.cartService.addToCart(product);
  }

67) cart-summary.component.ts'de bu service injection yapalým ve sepete eklenen arrayi getirecek service'de tanýladýðýmýz list metodunu burada çaðýralým

import { Component, OnInit } from '@angular/core';
import { CartItem } from 'src/app/models/cartItem';
import { CartService } from 'src/app/services/cart.service';

@Component({
  selector: 'app-cart-summary',
  templateUrl: './cart-summary.component.html',
  styleUrls: ['./cart-summary.component.css']
})
export class CartSummaryComponent implements OnInit {

  cartItems:CartItem[];

  constructor(private cartService:CartService) { }

  ngOnInit(): void {
    this.getCart();
  }

  getCart(){
    this.cartItems = this.cartService.list();
  }

}

68) Ama sayfayý refresh yaptýðýmýzda veri gidecek cart-summary.component.ts'de cartItems'a ilk deðer verelim öncelikle, html'de de *ngIf="cartItems.length>0" koþulu ekleyelim.

Veriyi belekte tutmak için ödevlerde araþtýracaðýz.

69) getbootstrap'ta Components'De Badge'te sorguyu alalým

<button type="button" class="btn btn-primary">
  Notifications <span class="badge bg-secondary">4</span>
</button>

70) Bunu html'de ilgili yere ekleyelim.

<li *ngIf="cartItems.length>0" class="nav-item dropdown">
  <a class="nav-link dropdown-toggle" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Sepetiniz
  </a>
  <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
    <li *ngFor="let cartItem of cartItems"><a
       class="dropdown-item">
         <span class="badge bg-secondary">{{cartItem.quantity}}</span>
      {{cartItem.product.productName}}</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><a class="dropdown-item" >Sepete git</a></li>
  </ul>
</li>

71) Buraya eklenen ürünleri de dropdown'da silmek için bir span oluþturalým.
<li *ngIf="cartItems.length>0" class="nav-item dropdown">
  <a class="nav-link dropdown-toggle" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Sepetiniz
  </a>
  <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
    <li *ngFor="let cartItem of cartItems"><a
       class="dropdown-item">
         <span class="badge bg-secondary">{{cartItem.quantity}}</span>
      {{cartItem.product.productName}}
      <span class="badge bg-secondary">Sil</span></a></li>
    <li><hr class="dropdown-divider"></li>
    <li><a class="dropdown-item" >Sepete git</a></li>
  </ul>
</li>

72) Sil'i ekledikten sonra removeFromCart metodunu cart.service.ts'de yapalým;

  removeFromCart(product:Product){
    let item = CartItems.find(c=> c.product.productId === product.productId);
    //splice metodu belirli bir indexten kaç tane silmek istediðimizi belirteceðimiz metot
    CartItems.splice(CartItems.indexOf(item),1);
  }

73) tsconfig.json'da "strictNullChecks": false, ekleyelim.

74) Service'te yaptýðýmýz metodu component'te çaðýracaðýz

  removeFromCart(product:Product) {
    this.cartService.removeFromCart(product);
  }

75) Bu metodu span'da Sil için olan yerde click yapýsý ile çaðýrmalýyýz;

<span (click)="removeFromCart(cartItem.product)" class="badge bg-secondary">Sil</span>

76) Bu yapýya toastr eklemek için componenet'te ToastrService injecte ederiz.

77) 
  removeFromCart(product:Product) {
    this.cartService.removeFromCart(product);
    this.toastrService.error("Silindi",product.productName + " sepetten silindi.")
  }

78) 









