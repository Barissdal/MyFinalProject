
CORE Katmaný = Framework yapacaðýz bu yaptýðýmýzý farklý projelerimizde de kullanabileceðiz. Bunu EfProductDal ve EfCategoryDal için yapmamýz gerekiyor çünkü bunlar ayný þeyleri yapýyor sadece alýnan paremetreler deðiþiyor.
Bunun için Class Library oluþturmalýyýz. Core -> Class Library

Bu CORE Katmanýnda evrensel kodlarýmý yazabilirim.

CORE Katmanýnda DataAccess folderý data access için evrensel kodlarýmý yazýyorum demektir.

NameSpace : Classlarý Interface lerý belli bir isim uzayýnda býrakýyoruz ki rahatça eriþebilielim diye.

***CORE Katmaný diðer katmanlarý referans almaz.Ozaman sadece o projeye baðýmlý olacaktýr bunu istemiyoruz.

IEntityRepository ve IEntity katmanlarýnýn Nortwind database i ile bir baðlantýsý yok. Bunlar global oyüden CORE Katmanýna atmamýz lazým.

CORE Katamnýna da veri tabaný eklememiz lazým oyüden Solutiýn sað click manage nuget aç ýnstall de EntityFrameWrodkCoreSQLSERVER'I CORA EKLE

EfProductDal artýk EfEntitiyRepositoryBase'i inherit alacaktýr. Çünkü IProductDal'a iliþkin methodlar artýk orada.
Burada IProductDal'ý da inherit etmemiz lazým. Bunu farklý server'lar baðlamak için lazým. IProductDal'ý product tablosuna iliþkin operasyonlarý kullanmak için kullanacaðýz.

Yeni bir Order class ý eklemek istersek;
1) Entities Class Library'de Order Class ý oluþturulur.
2) Data Access Class Library'de Abstract'ta Interfacý oluþturulur ve bu Interface IEntityRepository olduðu implement et.
3) Data Access Class Library'de EntityFrameWork'te EfOrderDal'ý hazýrla. Bunun da EfEntityRepositoryBase<Order, NorthwindContext>,IOrderDal olduðunu belirt.
Bundan sonra tüm sql operasyonlarýn hazýr olmuþ oluyor.

4) Veri tabaný Context'inde database'deki tablo ile bu yeni oluþturdum Order Class'ýnýn baðlamam lazým.

5) Business'ta Abstract Interface oluþturacaðýz. Burada Order'la ilgili dýþ dünyaya neyi servis etmek istiyorsak o operasyonlarý yazýyoruz.

6) Business Concrete'te Order'ýn iþ sýnýflarýný yazýyoruz.


7) Businnes manager sýnýflarýma Data Access'teki ilgili Interface'i implement ediyorum IOrderDal _orderDal;

8) Program.cs'de de daha önce yazdýðýmz kodlarý metod haline getirmek için seçip sað clikten quick actions refractoring ' i seçip metod yaptýk.

9) DTO (Data Transformation Object) : Join gibi operasyonlarý yapýyoruz. Entities'te klasor olarak oluþtur.

10) DTOs clasorunde ProductDetailDto classý oluþtur.

11) Core altýnda Entitites'te IDtos interface i oluþturulmalýdýr.
ProductDetailDto:IDto yapmayý unutma.

12) DataAccess'teki Interface'lerde join yapýsý oluþturulacak.

10.GÜN SONU KAYIT NOTLARI WEB API

1) Business'ta IProductService Add metodu ekleyelim.
2)Web API, yazdýðýmýz kodlarýn bir Angular, IOS vb. uygulamalarýn
anlamasýný saðlar.
WEB API ,Restful denilen bir formatla çalýþan json uygulamalarý
3) Client'larýn WEB API'ye yapacaklarý Requestler ile bizim vereceðimiz
Response larý yönetebilmek için bir alt yapý kuracaðýz.
4) Bu Request'lere Response döndürecekler Business'taki Managerlerdir.
Oyüden orasý için Base bir katman yazacaðýz.
5)Business'ta IProductService GetById metodu ekleyelim.
6) Bir metodtta sadece bir þey döndürebilirsin ama bir den fazla þey döndürmek istersen
Encapsulation yapman lazým.
7) Core Katmanýna Utilities(Araçlar) folderý ekleyelim.
8) Utilities'te de bir Results klasorü ekleyeceðiz Response larýmýz için.
Bu Result klasörü bizim result larýmýzý düenleyecek.
9) Result klasöründe IResult interfacý oluþturalým.
10) IResult ýn somut classýný Result olarak oluþtur.
11) Result'ta IResult ý implement ettikten sonra return tarafýna {get;}
12) IProductService eklediðimiz Add metodunu void deðil artýk IResult döndürmeli
13) ProductManager'da da ilgili void yerine IResult yapýyoruz. (Add metodu)
14) Bu Add metoduna return olarak artýk Result vermeliyiz.
15) return new Result(true,"Ürün eklendi.");
16) Burada Result'a çift týklayýp ampülden üsttekini seçiyoruz ve Reulst'a F12 ile gidiyoruz.
17) private deðiþkenleri ve metodun içindeki this leri siliyoruz.
17) Result'ta contructor kurulduðu için burada Message=message yapýyoruz yani aslýnda sadece get yapýlabilen deðiþlenleri
Contructor ile set leyebiliyoruz.
18) Add çalýþtýktan sonra mesaj döndürmek istemiyorsak ne yapacaðýz?
19) succes ve message parametresi alan constructor ý overload edecek sadece succes
parametresi alan bir Result contructor daha yazýyoruz.
20) public Result(bool success, string message):this(success)
        {
            Message = message;
        }

        public Result(bool success)
        {
            Success = success;
        }
21) this ile Result'ýn sadece success alan parametreli contructorý da çalýþþýn diyoruz.
22) Dolayýsýyla ProductManager'da IResult döndüren Add methodunda
iki parametreli Result'ý new lersen Result.cs de iki contructor da çalýþacak.
23) Bu yapýyý þimdi biraz daha profesyonel yapalým. SuccessResult, ErrorResult vb.
24) Results folderýnda SuccessResult yaratalým bu ayný zamanda Result,
burada Result contructor içerdiði için SuccessResult içinde constructor olmalý
25)SuccessResult construtorý oluþturuyoruz ve ;
public SuccessResult(string message):base(true,message) böyle tanýmlýyoruz
Buradaki base aslýnda Result'ý iþaret etmektedir.
Resulttaki ilk constructor success ve message parametreleri alýyordu.
Burada da succes olduðu için ona true diyoruz ve bir message parametresi giriyoruz.
26)ProductManager'da artýk add metodunda result yerine successresult ý çaðýrabiliriz.
27) ErrorResult ' ta oluþturalým.
28) ErrorResult için Business katmanýnda döndüreceðimiz string ler için bir yapý oluþturacaðýz.
29)Business ta Constants folder ý oluþturalým. Veritabanýmýza özel proje sabitlerini burada oluþtururuz.
30) Constants'ta Messages static bir class oluþturalým. Static verdiðimizde new lemeyz.
31)ProductManager'da artýk ErrorResult ve SuccesResult'ta Messages daki statik sabitlerimizi çaðýrabiliriz.
32)IProductService te GetAll için de IDataResult döndürsün.
Hem data, hem mesajý, hemde iþlem sonucu içeren bir yapýyý görevi görsün.
33) Core-Utilities-Results altýnda IDataResult interface oluþturalým.
Bu IDataResult ayný zamanda bir de IResult olacak çünkü orada mesaj ve iþlem sonucu da içermektedir.
34)IProductService'teki GetAll'da IDataResult<List<Product>> döndürecek.
Add metodu IResult kalýyor çünkü o bir void metottu Data içermiyor.
35)ProductManager'daki interface metodlarý artýk IDataResult istediði için onlarý güncelleyeceðiz.
Ayrýca return'lerde IDataResult'ýn somutu olan DataResult döndürmeliyiz.
Bunun için Results folderý na DataResult class ý oluþturalým.
Bunun Result'tan farklý data da içermesidir.
36) DataResult, hem Result hem de IDataResult 'týr.
37) Result için SuccessResult ve ErrorResult yaptýk;
DataResult için de SuccessDataResult ve ErrorDataResult yapalým.
38)SuccesDataResult ta çeþitli versiyonlar oluþturuyoruz.
39)Benzer þeyleri ErrorDataResult için de yap ve true larý false yapalaým.
40) ProductManager da return'lerde artýk ErrorDataResult ve SuccessDataResult new lenecek.
41) Program.cs'de ProductTest metodunda GetProductDetails artýk IDataResult döndürüyor onun için metodun
sonuna .Data yapalým.
42) ProductTest'te if koþullarý ekliyoruz.
43)Messages classýnda MaintenanceTime ile ProductsListed'ý string olarak açýklamasýný yazalým.
Onlarý da public yap internal yerine.


11.GÜN SONU KAYIT NOTLARI WEB API

Asp.net, .net projelerideki wep projesidir.
Api, bir Restful mimariyi destekler.
Restful mimari bizim geliþtiridðimiz .net'i tanýmayan sistemlerin entegre olmasýný saðlayan ortamdýr.

1) Solution üerinde Add Project -> Asp.net core web application
WebAPI için API'yý seçip uygun core versionumzu seçip create yapýyoruz.

2) Postmann test ortamýmýz.

3) WebAPI set as startup project yapýyoruz.

4) Controllers folder ý gelen bütün istekleri karþýlar.
Aslýnda bizim IProductService'teki metodlar için istek oluþturacaðýz.

5) Ä°stekler http ile gelecektir.

6) Controllers ta bize gelecek istekleri kodluyoruz aslýnda.

7) Controllers folderýna sað týkla Controllersý seç;
API'yý seçip empty olaný ekliyoruz. API'lerde controller isimleri çoðul yazýlýr.
Bu yüden ProductsController oluþturuyoruz.

8) ProductsController'de artýk Business'taki datalarý çaðýracaðýz.

9) Web API'ye, add project reference yapýyoruz.
Business, Core, DataAccess ve Entities için.

10) ProductsController' de Get için metod yazýyoruz List<Product> döndüren

11) Bir katman diðer katmanýn somutuyla baðlantý kurmamalý. !!!

12) IProductService'i constructor injection yapýypruz.

13) Bundan sonra çalýþtýrdðýmýzda hata alýyoruz çünkü Web Api somut bir nesne almadýðý için hangi
manageri döndüreceðini bilmiyor oyüden IoC devreye giriyor.

14) IoC Container aslýnda soyut varlýklarýmýzýn somutlarýný referans olarak tutan bir liste olarak
düþünebiliriz. Web Api'ye soyut varlýðýmýzý refere ettiðimizde onun IoC'deki somutunun referansýný döndürür.

15) WebApi'nin içinde Startup.cs ye gidiyoruz þimdi.

16) services.AddSingleton<IProductService,ProductManager>();
Sen IProductService görüyorsan bunu ProductManager new le diye ifade ederiz.
AddSingleton'ý içinde data tutmadýðýmýz yapýlar için kullanýrýz.

17) Burada da ProductManager contructor'ý da içinde IProductDal içerdiði için,
bunu da AddSingleton'da bunun EfProductDal olduðu ifade etmemiz lazým.

18) Bu yapýyý farklý bir mimariye taþýyacaðýz.
Autofac, Ninject, CastleWindsor, StructureMap, LightInject, DryInject -->IoC Container

19) Artýk AOP yapacaðýz.
AOP= Bütün metodlarýmýzý log lamak istediðimizde kullanýrýz.
Bir metodun önünde, sonunda ve ya bir metot hata verdiðinde çalýþan kodlarý
AOP'de yazýyoruz.  Log vb. için

20) Postman daki Status kýsmý Server'ýn ne döndürdüðünü ifade eder.
Ã–rneðin yetkisi olmayanlar için status 400K olur. Yni buradan alýnan yanýta göre ekran
yapýlandýrýlacak.

21) ProductController deki Get IActionResult olacak þekilde düeltelim.

22) Get metodunu result.Success ise döndüreceðimiz status için duruma göre Ok ve BadRequest olarak
döndürelim.

Çalýþtýrdýðýmýzda açýlan browser da url alanýna domain den sonra api/httpger ve ya post'un içine ne yazdýysak öyle çaðýrýyoruz.
örneðin domain/api/products/getall

23) ProductManager'da bu durumu test edelim çalýþtýðým saatte sistem bakýmda olsun.
Status'te ne dönecek test edelim.

24) Status 400 Bad Request olarak güncellendi sonuçta.
Çünkü ben saat 16:00'da sistem bakýmda dedim.

25) Åžimdi post requesti yazacaðýz.

[HttpPost]

26) Post metoduna nesne olarak Product'ý verebiliriz.

27) Post request'lerde data vermemiz lazým.
Postman'da Post'u seçip send dedikten sonra
Body -> raw -> JSON'ý seçelim. Burada JSON formatýnda Product giriþi yapmamýz lazým.
Bunun için Get'ti çalýþtýrýp oradan gelen JSON formatýný kopyalayabiliriz.

    {
        "categoryId": 1,
        "productName": "Bardak",
        "unitsInStock": 15,
        "unitPrice": 25
    }

28) Bunu send ettiðimizde artýk veritabanýna bu bilgileri ekler.

29) Bir Get daha oluþturalým. Bunun için ilkine [HttpGet("getall")]
ikincisine [HttpGet("getbyid")] ; post için de [HttpPost("add")]
Metotlarýn adýný da Get=GetAll vb. yapalým

30) Postman'da artýk GET'TE api/products/getall ; getbyid?id=1 
POST'TA api/products/add kullanarak veri giriþi yapabiliriz.

31) Update ve Delete içinde Post kullanýlabilir.Ama update içinde HttpPut da var.

12.GÜN SONU KAYIT NOTLARI WEB API

1) IoC altyapýsýný biraz daha ileri seviyeye taþýyacaðýz.

2) .Net'in kendi IoC altyapýsý olsa da AOP tekniklerini kullanmak için
baþka Container larla destekleyeceðiz.

3) Autofac ücretsiz ve daha hýzlý olduðu için kullanacaðýz;
Postsharp da çok iyi ama ücretlidir.

4) Autofac, instance üretimini bizim için saðlayan bir yapýya sahiptir.

5) Biz bu yapýlanmayý Startup.cs de yapmak yerine Back-end de yapmalýyýz.
Çünkü baþka bir api ve ya birden fazla api kullanacaksak ilerde bunu .Net Core içerisinde Containerlarý
kullanmamýz lazým.

6) Businnes üzerinde saða týkla Manage NuGet Packages ->
Browse -> autofac -> Autofac by Autofac Contributors -> 
Version son sürüm kullanýlabilir

7) Browse -> autofac.extras -> install
(Java daki Spring gibi)

8) Businnes ta bir klasor oluþturalým = DependencyResolvers

9) DependencyResolvers'ta da Service lerin ve Interface lerin karþýlýklarýný
autofac kullanarak belirtmiþ olacaðýz.

10) DependencyResolvers' ta Autofac klasörü oluþturalým.

11) Autofac içerisinde bir AutofacBusinessModule classý oluþturalým.

12) BU class a sen bir Module 'sun diyeceðiz ama buradaki Module; using Autofac;

13) over yaz space a baþ bekle orada ezebileceðimiz metodlarý görsterir.

14) Orada Load 'ý seçiyoruz.

//birisi senden IProductService isterse ona bir tabe ProductManager örneði ver.
builder.RegisterType<ProductManager>().As<IProductService>().SingleInstance();
builder.RegisterType<EfProductDal>().As<IProductDal>().SingleInstance();

15) Startup'a gidip daha önce yaptýðýmýz AddSingleton ' larý commentleyelim.

16) Bunlarýn yerine biz kendi Autofac yapýmýzý tanýtmamýz lazým.

17) Bunu Web API'DE Program.cs de yapacaðýz.

18) CreateHostBuilder metodunda .UseServiceProviderFactory(new AutofacServiceProviderFactory())

AutofacServiceProviderFactory için install package'ý ampulden yapalým.

19) .ConfigureContainer<ContainerBuilder>(builder=>
                {
                    builder.RegisterModule(new AutofacBusinessModule());
                })


20) Burada biz .Net'e kendi IoC yapýný kullanma benim AutofacBusinessModule'u kullanmalýsýn dedik.

21) Validation, varlýklarýn yapýsal kontrollerine bakar. Þifre bu kurallara uymalý, isim min 2 karekter olmalý gibi.

22) Business'ta ValidationRules folder ý oluþtur.

23) ValidationRules 'ta FluentValidation klasoru oluþturalým.

24) Business -> Manage Nuget Packages -> fluentvalidation (jeremy skinner) install

25) FluentValidation 'da ProductValidator classý ekle

26) Bu ProductValidator aslýnda AbstractValidator<Product>

27) Bu kurallar bir contructor içine yazýlýr.

28) RuleFor(c => c.DailyPrice).NotEmpty(); vb.

29) Burada yeni bir kuralda biz ekleyebiliriz.

30) Ürünlerimin ismi A ile baþlasýn kularý eklemek istersek;

	RuleFor(p=>p.ProductName).Must(StartWithA);

31) (StartWithA) 'ye generic metod dersen oluþturur.

32) private bool StartWithA(string arg)
        {
            return arg.StartsWith("A");
        }

33) ProductManager Add metodu içinde koþullarý silebiliriz artýk.

34) Add içinde ValidationContext i oluþturalým.

35) var context = new ValidationContext<Car>(car);
            CarValidator carValidator = new CarValidator();
            var result = carValidator.Validate(context);

            if (!result.IsValid)
            {
                throw new ValidationException(result.Errors);
            }


burada refactor edeceðiz. Çünkü yukardaki deðiþenler Car entity ve CarValidator

36) Bu yapý her yerde kullanabileceðim için Core a taþýmalýyým.

37) Corss Cutting Concerns, dikey kesen yapýlar (loglama , cache, validation , transaction, authorization vb.)

38) Core'da CrossCuttingConcerns folderý ekleyelim.

39) CrossCuttingConcerns'de Validation folderý ekleyelim.

40) Validation'da ValidationTool clasý oluþtur.

41) 35'teki kodu buraya atacaðýz ve bu class static olacak.

42) Bu classýn içinde Validate metodu oluþturacaðýz. Bu metod parametre olarak CarValidator için bir IValidator bir de entity için object alacak.

43) public static void Validate(IValidator validator, object entity )
        {
            var context = new ValidationContext<object>(entity);
            var result = validator.Validate(context);

            if (!result.IsValid)
            {
                throw new ValidationException(result.Errors);
            }
        }

44) CarManager'da bu yaptýðýmýz metodu çaðýrmamýz gerekecektir;

	ValidationTool.Validate(new CarValidator(),car);

45) Ama bunun gibi validation, loglama, cache, transaction, yetkilendirme gibi þeyler yapacaðýz bunlarýn hepsini
add metodunda alt alta yazmayalým.

46) Bu yapýlarý kurmak için Aspect kullanmalýyýz.

47) Aspect'ler için bazý kodlara ihtiyacýmýz var bunu Engin Hocanýn githubta NetCoreBackend projesinden alacaðýz.

48) Core-Utilities-Interceptors'ta AspectInterceptorSelector;MethodInterception;ModelInterceptionBaseAttiribute

49) AOP = Uygulamanýn metodun baþýnda, sonunda ve ya hata verdiðinde dizayn etmektir.

50) Core katmanýmýzda Utilites altýnda Interceptors folderý ekleyelim.

51) ModelInterceptionBaseAttiribute kodunu kopyala namespace dýþýndakileri

52) Interceptors folderýne bir class ekle isim verme þimdilik

53) class olan yere kopyaladýðýmýzý yapýþla.

54) Solution üzerinde Manage Nuget packages tan Install'da autofac olan 3ünü Core a ekleyeceðiz.

55) Github ta MethodInterception kodunu kopyalayalým.

56) Buradaki kodlar metotlarýn çalýþmadan önceki validationlarýný sorgulayacak alandýr.

57) Aspect'te burasý için hangi durumu doldurusak o çalýþacak OnBefore mu OnAfter mý vb.

58) Bu kopyaladýðýmýzý da oluþturduðumuz class a ekleyelim.

59) Github ta  AspectInterceptorSelector kopyala

60) Bu kod class'ýn , metotun attributelarýný oku bunlarý listele. Bunlarýn sýrasýný da önceliklerine göre sýrala.

61) Burada loglama kýsmýný commnet yapalým þimdilik.

62) MethodInfo yu çözersek hepsi düzelecektir.

63) Bu kopyalayýp yapýþtýrdýklarýmýzý ayýrmak için ModelInterceptionBaseAttiribute üzerine imleci býrak ampulden
move type to.... týkla

64) MethodInterception içinde aynýsýný yap son kalan içinde rename yapalým.

65) Core'a Aspects kalsoru ekle

66) Autofac'i kullanarak Aspects yazacaðýmýz için Aspects klasoru ekle.

67) Burada þimdi validation yapacaðýmýz için Validation klasoru ekle.

68) Github ta Core/Aspects/Autofac/Validation/ValidationAspect.cs kopyala

69) Validation klasorunde bizde class ekleyelim ve kopyaladýðýmýzý o class yerine yapýþtýrç

70) ValidationAscpect bir type ister. Örneðin Add metodunu CarValidator kullanarak doðrula deriz.

71) Manager'da artýk ValidationTool clasýnýn metoduna gerek kalmadý.
Add üstünde [ValidationAspect(typeof(CarValidator))] ekle.

72) Þu anda Manager'da add metounda validation yok ama aspect ekledik.

73) Þimdi bu Interceptor larýn devreye girmesini söylememiz lazým.

74) Githubta Business/DependencyResolvers/Autofac/AutofacBusinessModule.cs var assembly ile baþlayan kodu kopyala

Bu kod builder.daki butun sýnýflar için önce git Aspect'i var mý bak der.

75) Business/DependencyResolvers/Autofac/AutofacBusinessModule.cs da load metodunun içine yapýþtýralým.

#13.GÜN DERS NOTLARI

1) Örnek bir demo yapacaðýz AOP için bunu sileceðiz sonra

2) Business'ta CCS(Cross Cutting Conserns) folderý ekle.

3) Burada ILogger interfaci ekle

4) Burada void Log metodu olsun

5) CCS üzerinde FileLogger classý ekle

6) Bu FileLogger:ILogger 

7) Log metdounu implement edip bir açýklama ekrana yazdýralým.

8) Bir tane de DatabaseLogger clasýý ekleyelim ve Log metodunu yine yazalým.

9) ProductManager'deki ValidationAspect'i þimdilik comment yapalým.

10) ProductManager de bu ILogger interfaci construct injection yapalým.

11) Zaten ProductManager'ýn contructor ý var buraya ILogger'ý da ekliyoruzç

12) Bu ILogger interface Autofac'e tanýtmak için AutofacBusinessModule'de ILogger'ý da ekle

13) ProductManager'da Add metodunun içinde try catch yap

14) Metodu çaðýrma ve return'u try içine at, try'dan önce log metodunu çaðýr

15) Baþarýsýz olursa catch'te de log u çaðýr. Burada hem baþarýlý ekleme olursa
hemde baþarýsýz olursa log lama yaptýk.

16) try catch'den sonrada ErrorResult döndürebiliriz.

17) Burada iþ kodlarýmýz olabilir, diðer dikey kesenlerimiz olabilir burasý karmaþýk olur

18) Bu çalýþmalarý AOP ile merkezi bir noktaya taþýrýz.

19) Core'da Utilities'de Interceptors klasorunde MethotInterception class var.
Buradaki virtual metotlar ezilebilecek mototlardýr. 

20) Core.Aspects.Autofac.Validation da isim vermediðimiz class vardý onun ismini
rename yapalým ValidationAspect olarak.

21) Core.CrossCuttingConcerns.Validation da ValidationTool clasýmýz ;
Bir tane IValidator ve bir tane class istemektedir. 

22) ValidationAspect, metodun baþýnda sonunda hata verdiðinde çalýþacak yapýdýr.

23) Validation doðrulama olduðu için sadece OnBefore u tanýmlamýþtýk.

24) Clean Code yapýyoruz ....

25) Bir ürün eklemek istersem eklemek istediðim ürünün kategorisinde maksimum 
10 ürün olabilir. Bunun kodunu yazalým.

26) IProductService'te Update metodu yokmuþ onu ekleyelim.

27) Manager'da Update metodunu implement et ve baþýna validation ekle

28) 25'teki durumu add metodunda da kullanacaðýz update de de oyüzden kendimizi
tekrar etmemeiz lazým.

29) Bu yüzden bir iþ kuralý yazacaksak eðer manager'de en alta gelip fonksiyon(metot) olarak
yazmamýz gerekecektir.

30) Bu metot sadece manager class'ýnda kullanýlýndýðý için private olarak yazýlmalý.

31) Bu metodun adýný da CheckIfProductCountOfCategoryCorrect yazalým ve kod parçacýðýmýzý yazalým.

32) private IResult CheckIfProductCountOfCategoryCorrect(int categoryId)
        {
            var result = _productDal.GetAll(p => p.CategoryId == categoryId).Count;

            if (result >= 10)
            {
                return new ErrorResult(Messages.ProductCountOfCategoryError);
            }
            return new SuccessResult();
        }

33) Bu metodu artýk nerede kullanmak istersek kullanabiliriz.

34) if (CheckIfProductCountOfCategoryCorrect(product.CategoryId).Success)
            {
                _productDal.Add(product);

                return new SuccessResult(Messages.ProductAdded);
            }
            return new ErrorResult();

35) Ayný isimde ürün eklenemez

36) Bir metot daha ekleyip yukarýdaki if ile baðlayabiliriz.

37) CheckIfProductNameExists adýyla metot ekleriz.

38) Burada birden çok metot varsa iç içe bir sürü if olacak.

39) Bu yazdýðýmýz iþ kurallarýný refactor edelim. Çünkü iþ kurallarýmýz hep IResult döndürmektedir. Bunlarý þimdi bir
iþ motoru olarak yazalým. 

40) Bu iþ kurallarý bütün projelerde yapýlabilir çünkü zaten IResult yapýsý döndürdüðüm için bunlarý Core'da
tanýmlayabilirim.

41) Core-Utilities'de Business folderý ekle ve onda da BusinessRules classý ekle.

42) Burada da bir Run metodu yazalým.

43) ProductManager'da þimdi Business.Run metodunu içine daha önce yazdýðýmýz IResult döndüren 2 metodu verebiliriz.

44) Bu metot bir IResult döndürür oyüzden bunu bir IResult deðiþkenine atayalým ve burada kurala uymama koþulunu yazalým.

45) Artýk bu iþ kurallarýna göre add çalýþtýrýlabilir ve yeni bir iþ kuralý gelirse Business.Run metoduna ekle

46) Yeni kuralýmýz eðer mevcut kategori sayýsý 15'i geçtiyse sisteme yeni ürün eklenemez.

47) Bu kural microservice mimarisine nasýl yaklaþacaðýmýzý gösterecektir.

48) Bir entitymanager kendisi hariç baþka bir dal'ý enjekte edemez ama service enjekte edebiliriz.

49) Çünkü yeni kurallar geldiðinde ICategoryDal'ý her yerde yazman lazým.

50) CategoryDal için biz bir service yazdýk ve ona ait kurallarý orada belirtmiþtik zaten.

51) ICategoryService'i de refactor etmemiz lazým.

52) CategoryManager'da ilgili düzenlemeleri yap.

53) Her entity'nin kendi service olmalý.

54) Artýk ProductManager'da 46 nolu maddedeki koþul için metot yazabiliriz.

55) Bunu da artýk Business.Run içerisine ekleyebiliriz.

56) Program.cs ' de ProductManager'i çaðýrdýðýmýz için oraya da CategoryManager'i de ekleyelim.

57) Business.DependencyResolvers.Autofac'te AutofacBusinessModule'de CategoryManager ekle

#14.GÜN DERS NOTLARI

1) Add operasyonu için SecuredOperation diye bir aspect yazmak isteyeceðiz.

2) Bu metotu çaðýracak kiþinin admin,editor vb. yetkilere sahip olmasý gerekebilir.

3) Bu yetkilendirme ihtiyaca göre deðiþkendir.

4) Operasyon bazýnda da yetkilendirme yapmamýz gerekebilir.

5) Add metodunu admin yapsýn örneðin

6) Claim=Bu kullanýcýnýn admin gibi claimlerinden birine sahip olmasý gerekir;
Yani admin,editor vb. þeylere claim diyoruz.

7) Api bazlý yapýlarda json bazlý bir token dan yararlanýlýr = jwt(jsonwebtoken)

8) Encryption, Hashing bunlar karþý tarafýn verilerimizi okumamasýný saðlayacak yapýlar.

9) Kullanýcý parolalarý hash lenir.

10) Parolalar; MD5, SHA1 gibi hashleme algoritmalarýyla geri dönüþtürülemeyecek þekilde haslenir.

11) Kullanýcý ama þifresini girdiðinde hashlenmemiþ halini giriyor sonuçta kullanýcý log in butonuna týkladýktan sonra
yine hasleme algoritmasýyla o hashlenir ve veritabanýndaki hashlenmiþ verilerle karþýlaþtýrýlýr.

12) Salting, kullanýcýnýn girdiði parolayý biraz daha güçlendirme iþlemi.Bunu biz kendimiz ekliyoruz.

13) Encryption geri dönüþü olan veridir. Ýlgili data encrpt ediliyor ve bu da çözülebilir.

14) Burada key denilen anahtarlar ortaya çýkmaktadýr.

15) SeucredOperation için kullanýcýlar, kullanýcýlarýn claim leri ve bu ikisi iliþkilendirmek için 3 tabloya ihtiyaç var.

16) Northwind veritabanýnda Tables'da sað click Add New Table yapalým.

17) User tablosunu oluþturalým. Id alanýný sað click yapýp Properties'ten Identity alanýný true yapalým.

18) Update tuþu ile update edelim ve tabomuz oluþsun.

19) OperationClaims tablosu ayný þekilde oluþturalým.

20) UserOperationClaims tablosu ekle.

21) Þimdi bunlarýn Entity'de class larýný oluþturalým ama bunlarý bütün projelerimizde
kullanabileceðimiz için bunlarý Core'da Entities içerisine Concrete folder ý ekleyelim.
Burada class larý oluþturalým.

22) User, OperationClaim ve UserOperationClaim class larý ekleyelim.

23) Web API' de appsettings.json dosyasý var. Bu dosya WebAPI nin ayarlarýnýn olduðu yerdir.
Burada bizde TokenOptions adýyla bir anahtar oluþturacaðýz.

24) Jwt nin olmazsa olmaz alanlarýný burada yazalým.

25) "Audience",Issuer, AccessTokenExpiration(bizim verdiðimiz token nýn dakika olarak geçerlilik süresi)
SecurityKey(token için kullanýlacak anahtar ismi)

30) Core'da Utilities'de Security folderý ekleyelim.

31) Burada da Hashing, Encryption ve JWT klasorlerý ekleyelim.

32) Hashing'te bir tane hashlame aracý yazmak için bir HashingHelper class ekleyelim.

33) Bu classta iki metot olacak. Birisi hash leme yapacak ikincisi de doðrulama yapacak.

34) Encryption klasorunda SecurityKeyHelper class ý ekle

35) Biz bu yapýlarda herþeyi byte arrayi ile oluþturmamýz gerekir.

36) Core'da Manage Nuget Packages Browse -> Microsoft.Identity -> Model.Tokens install

37) SecurityKeyHelper classýndaki SecurityKey appsettings.json da tanýmladýðýmýz SecurityKey'dir.

38) Encryption klasorunda SigningCredentialsHelper classý ekle

39) Burada da bir güvenlik anahtarý ve þifreleme algoritmasýný tanýmlýyoruz. 

40) JWT klasorunde AccessToken classý ekle

41) Anlamsýz deðerlerden oluþan bir anahtar deðeri ve bir bitiþ tarihi bulunacak bu class ta

42) Bu AccessToken'ý oluþturmak için bir ITokenHelper interface i oluþturalým.

43) 