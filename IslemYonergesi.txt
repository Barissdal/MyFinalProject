
CORE Katmaný = Framework yapacaðýz bu yaptýðýmýzý farklý projelerimizde de kullanabileceðiz. Bunu EfProductDal ve EfCategoryDal için yapmamýz gerekiyor çünkü bunlar ayný þeyleri yapýyor sadece alýnan paremetreler deðiþiyor.
Bunun için Class Library oluþturmalýyýz. Core -> Class Library

Bu CORE Katmanýnda evrensel kodlarýmý yazabilirim.

CORE Katmanýnda DataAccess folderý data access için evrensel kodlarýmý yazýyorum demektir.

NameSpace : Classlarý Interface lerý belli bir isim uzayýnda býrakýyoruz ki rahatça eriþebilielim diye.

***CORE Katmaný diðer katmanlarý referans almaz.Ozaman sadece o projeye baðýmlý olacaktýr bunu istemiyoruz.

IEntityRepository ve IEntity katmanlarýnýn Nortwind database i ile bir baðlantýsý yok. Bunlar global oyüzden CORE Katmanýna atmamýz lazým.

CORE Katamnýna da veri tabaný eklememiz lazým oyüzden Solutiýn sað click manage nuget aç ýnstall de EntityFrameWrodkCoreSQLSERVER'I CORA EKLE

EfProductDal artýk EfEntitiyRepositoryBase'i inherit alacaktýr. Çünkü IProductDal'a iliþkin methodlar artýk orada.
Burada IProductDal'ý da inherit etmemiz lazým. Bunu farklý server'lar baðlamak için lazým. IProductDal'ý product tablosuna iliþkin operasyonlarý kullanmak için kullanacaðýz.

Yeni bir Order class ý eklemek istersek;
1) Entities Class Library'de Order Class ý oluþturulur.
2) Data Access Class Library'de Abstract'ta Interfacý oluþturulur ve bu Interface IEntityRepository olduðu implement et.
3) Data Access Class Library'de EntityFrameWork'te EfOrderDal'ý hazýrla. Bunun da EfEntityRepositoryBase<Order, NorthwindContext>,IOrderDal olduðunu belirt.
Bundan sonra tüm sql operasyonlarýn hazýr olmuþ oluyor.

4) Veri tabaný Context'inde database'deki tablo ile bu yeni oluþturdum Order Class'ýnýn baðlamam lazým.

5) Business'ta Abstract Interface oluþturacaðýz. Burada Order'la ilgili dýþ dünyaya neyi servis etmek istiyorsak o operasyonlarý yazýyoruz.

6) Business Concrete'te Order'ýn iþ sýnýflarýný yazýyoruz.


7) Businnes manager sýnýflarýma Data Access'teki ilgili Interface'i implement ediyorum IOrderDal _orderDal;

8) Program.cs'de de daha önce yazdýðýmz kodlarý metod haline getirmek için seçip sað clikten quick actions refractoring ' i seçip metod yaptýk.

9) DTO (Data Transformation Object) : Join gibi operasyonlarý yapýyoruz. Entities'te klasor olarak oluþtur.

10) DTOs clasorunde ProductDetailDto classý oluþtur.

11) Core altýnda Entitites'te IDtos interface i oluþturulmalýdýr.
ProductDetailDto:IDto yapmayý unutma.

12) DataAccess'teki Interface'lerde join yapýsý oluþturulacak.

10.GÜN SONU KAYIT NOTLARI WEB API

1) Business'ta IProductService Add metodu ekleyelim.
2)Web API, yazdýðýmýz kodlarýn bir Angular, IOS vb. uygulamalarýn
anlamasýný saðlar.
WEB API ,Restful denilen bir formatla çalýþan json uygulamalarý
3) Client'larýn WEB API'ye yapacaklarý Requestler ile bizim vereceðimiz
Response larý yönetebilmek için bir alt yapý kuracaðýz.
4) Bu Request'lere Response döndürecekler Business'taki Managerlerdir.
Oyüzden orasý için Base bir katman yazacaðýz.
5)Business'ta IProductService GetById metodu ekleyelim.
6) Bir metodtta sadece bir þey döndürebilirsin ama bir den fazla þey döndürmek istersen
Encapsulation yapman lazým.
7) Core Katmanýna Utilities(Araçlar) folderý ekleyelim.
8) Utilities'te de bir Results klasorü ekleyeceðiz Response larýmýz için.
Bu Result klasörü bizim result larýmýzý düzenleyecek.
9) Result klasöründe IResult interfacý oluþturalým.
10) IResult ýn somut classýný Result olarak oluþtur.
11) Result'ta IResult ý implement ettikten sonra return tarafýna {get;}
12) IProductService eklediðimiz Add metodunu void deðil artýk IResult döndürmeli
13) ProductManager'da da ilgili void yerine IResult yapýyoruz. (Add metodu)
14) Bu Add metoduna return olarak artýk Result vermeliyiz.
15) return new Result(true,"Ürün eklendi.");
16) Burada Result'a çift týklayýp ampülden üsttekini seçiyoruz ve Reulst'a F12 ile gidiyoruz.
17) private deðiþkenleri ve metodun içindeki this leri siliyoruz.
17) Result'ta contructor kurulduðu için burada Message=message yapýyoruz yani aslýnda sadece get yapýlabilen deðiþlenleri
Contructor ile set leyebiliyoruz.
18) Add çalýþtýktan sonra mesaj döndürmek istemiyorsak ne yapacaðýz?
19) succes ve message parametresi alan constructor ý overload edecek sadece succes
parametresi alan bir Result contructor daha yazýyoruz.
20) public Result(bool success, string message):this(success)
        {
            Message = message;
        }

        public Result(bool success)
        {
            Success = success;
        }
21) this ile Result'ýn sadece success alan parametreli contructorý da çalýþþýn diyoruz.
22) Dolayýsýyla ProductManager'da IResult döndüren Add methodunda
iki parametreli Result'ý new lersen Result.cs de iki contructor da çalýþacak.
23) Bu yapýyý þimdi biraz daha profesyonel yapalým. SuccessResult, ErrorResult vb.
24) Results folderýnda SuccessResult yaratalým bu ayný zamanda Result,
burada Result contructor içerdiði için SuccessResult içinde constructor olmalý
25)SuccessResult construtorý oluþturuyoruz ve ;
public SuccessResult(string message):base(true,message) böyle tanýmlýyoruz
Buradaki base aslýnda Result'ý iþaret etmektedir.
Resulttaki ilk constructor success ve message parametreleri alýyordu.
Burada da succes olduðu için ona true diyoruz ve bir message parametresi giriyoruz.
26)ProductManager'da artýk add metodunda result yerine successresult ý çaðýrabiliriz.
27) ErrorResult ' ta oluþturalým.
28) ErrorResult için Business katmanýnda döndüreceðimiz string ler için bir yapý oluþturacaðýz.
29)Business ta Constants folder ý oluþturalým. Veritabanýmýza özel proje sabitlerini burada oluþtururuz.
30) Constants'ta Messages static bir class oluþturalým. Static verdiðimizde new lemeyz.
31)ProductManager'da artýk ErrorResult ve SuccesResult'ta Messages daki statik sabitlerimizi çaðýrabiliriz.
32)IProductService te GetAll için de IDataResult döndürsün.
Hem data, hem mesajý, hemde iþlem sonucu içeren bir yapýyý görevi görsün.
33) Core-Utilities-Results altýnda IDataResult interface oluþturalým.
Bu IDataResult ayný zamanda bir de IResult olacak çünkü orada mesaj ve iþlem sonucu da içermektedir.
34)IProductService'teki GetAll'da IDataResult<List<Product>> döndürecek.
Add metodu IResult kalýyor çünkü o bir void metottu Data içermiyor.
35)ProductManager'daki interface metodlarý artýk IDataResult istediði için onlarý güncelleyeceðiz.
Ayrýca return'lerde IDataResult'ýn somutu olan DataResult döndürmeliyiz.
Bunun için Results folderý na DataResult class ý oluþturalým.
Bunun Result'tan farklý data da içermesidir.
36) DataResult, hem Result hem de IDataResult 'týr.
37) Result için SuccessResult ve ErrorResult yaptýk;
DataResult için de SuccessDataResult ve ErrorDataResult yapalým.
38)SuccesDataResult ta çeþitli versiyonlar oluþturuyoruz.
39)Benzer þeyleri ErrorDataResult için de yap ve true larý false yapalaým.
40) ProductManager da return'lerde artýk ErrorDataResult ve SuccessDataResult new lenecek.
41) Program.cs'de ProductTest metodunda GetProductDetails artýk IDataResult döndürüyor onun için metodun
sonuna .Data yapalým.
42) ProductTest'te if koþullarý ekliyoruz.
43)Messages classýnda MaintenanceTime ile ProductsListed'ý string olarak açýklamasýný yazalým.
Onlarý da public yap internal yerine.








