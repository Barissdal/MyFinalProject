
CORE Katmaný = Framework yapacaðýz bu yaptýðýmýzý farklý projelerimizde de kullanabileceðiz. Bunu EfProductDal ve EfCategoryDal için yapmamýz gerekiyor çünkü bunlar ayný þeyleri yapýyor sadece alýnan paremetreler deðiþiyor.
Bunun için Class Library oluþturmalýyýz. Core -> Class Library

Bu CORE Katmanýnda evrensel kodlarýmý yazabilirim.

CORE Katmanýnda DataAccess folderý data access için evrensel kodlarýmý yazýyorum demektir.

NameSpace : Classlarý Interface lerý belli bir isim uzayýnda býrakýyoruz ki rahatça eriþebilielim diye.

***CORE Katmaný diðer katmanlarý referans almaz.Ozaman sadece o projeye baðýmlý olacaktýr bunu istemiyoruz.

IEntityRepository ve IEntity katmanlarýnýn Nortwind database i ile bir baðlantýsý yok. Bunlar global oyüzden CORE Katmanýna atmamýz lazým.

CORE Katamnýna da veri tabaný eklememiz lazým oyüzden Solutiýn sað click manage nuget aç ýnstall de EntityFrameWrodkCoreSQLSERVER'I CORA EKLE

EfProductDal artýk EfEntitiyRepositoryBase'i inherit alacaktýr. Çünkü IProductDal'a iliþkin methodlar artýk orada.
Burada IProductDal'ý da inherit etmemiz lazým. Bunu farklý server'lar baðlamak için lazým. IProductDal'ý product tablosuna iliþkin operasyonlarý kullanmak için kullanacaðýz.

Yeni bir Order class ý eklemek istersek;
1) Entities Class Library'de Order Class ý oluþturulur.
2) Data Access Class Library'de Abstract'ta Interfacý oluþturulur ve bu Interface IEntityRepository olduðu implement et.
3) Data Access Class Library'de EntityFrameWork'te EfOrderDal'ý hazýrla. Bunun da EfEntityRepositoryBase<Order, NorthwindContext>,IOrderDal olduðunu belirt.
Bundan sonra tüm sql operasyonlarýn hazýr olmuþ oluyor.

4) Veri tabaný Context'inde database'deki tablo ile bu yeni oluþturdum Order Class'ýnýn baðlamam lazým.

5) Business'ta Abstract Interface oluþturacaðýz. Burada Order'la ilgili dýþ dünyaya neyi servis etmek istiyorsak o operasyonlarý yazýyoruz.

6) Business Concrete'te Order'ýn iþ sýnýflarýný yazýyoruz.


7) Businnes manager sýnýflarýma Data Access'teki ilgili Interface'i implement ediyorum IOrderDal _orderDal;

8) Program.cs'de de daha önce yazdýðýmz kodlarý metod haline getirmek için seçip sað clikten quick actions refractoring ' i seçip metod yaptýk.

9) DTO (Data Transformation Object) : Join gibi operasyonlarý yapýyoruz. Entities'te klasor olarak oluþtur.

10) DTOs clasorunde ProductDetailDto classý oluþtur.

11) Core altýnda Entitites'te IDtos interface i oluþturulmalýdýr.
ProductDetailDto:IDto yapmayý unutma.

12) DataAccess'teki Interface'lerde join yapýsý oluþturulacak.

10.GÜN SONU KAYIT NOTLARI WEB API

1) Business'ta IProductService Add metodu ekleyelim.
2)Web API, yazdýðýmýz kodlarýn bir Angular, IOS vb. uygulamalarýn
anlamasýný saðlar.
WEB API ,Restful denilen bir formatla çalýþan json uygulamalarý
3) Client'larýn WEB API'ye yapacaklarý Requestler ile bizim vereceðimiz
Response larý yönetebilmek için bir alt yapý kuracaðýz.
4) Bu Request'lere Response döndürecekler Business'taki Managerlerdir.
Oyüzden orasý için Base bir katman yazacaðýz.
5)Business'ta IProductService GetById metodu ekleyelim.
6) Bir metodtta sadece bir þey döndürebilirsin ama bir den fazla þey döndürmek istersen
Encapsulation yapman lazým.
7) Core Katmanýna Utilities(Araçlar) folderý ekleyelim.
8) Utilities'te de bir Results klasorü ekleyeceðiz Response larýmýz için.
Bu Result klasörü bizim result larýmýzý düzenleyecek.
9) Result klasöründe IResult interfacý oluþturalým.
10) IResult ýn somut classýný Result olarak oluþtur.
11) Result'ta IResult ý implement ettikten sonra return tarafýna {get;}
12) IProductService eklediðimiz Add metodunu void deðil artýk IResult döndürmeli
13) ProductManager'da da ilgili void yerine IResult yapýyoruz. (Add metodu)
14) Bu Add metoduna return olarak artýk Result vermeliyiz.
15) return new Result(true,"Ürün eklendi.");
16) Burada Result'a çift týklayýp ampülden üsttekini seçiyoruz ve Reulst'a F12 ile gidiyoruz.
17) private deðiþkenleri ve metodun içindeki this leri siliyoruz.
17) Result'ta contructor kurulduðu için burada Message=message yapýyoruz yani aslýnda sadece get yapýlabilen deðiþlenleri
Contructor ile set leyebiliyoruz.
18) Add çalýþtýktan sonra mesaj döndürmek istemiyorsak ne yapacaðýz?
19) succes ve message parametresi alan constructor ý overload edecek sadece succes
parametresi alan bir Result contructor daha yazýyoruz.
20) public Result(bool success, string message):this(success)
        {
            Message = message;
        }

        public Result(bool success)
        {
            Success = success;
        }
21) this ile Result'ýn sadece success alan parametreli contructorý da çalýþþýn diyoruz.
22) Dolayýsýyla ProductManager'da IResult döndüren Add methodunda
iki parametreli Result'ý new lersen Result.cs de iki contructor da çalýþacak.
23) Bu yapýyý þimdi biraz daha profesyonel yapalým. SuccessResult, ErrorResult vb.
24) Results folderýnda SuccessResult yaratalým bu ayný zamanda Result,
burada Result contructor içerdiði için SuccessResult içinde constructor olmalý
25)SuccessResult construtorý oluþturuyoruz ve ;
public SuccessResult(string message):base(true,message) böyle tanýmlýyoruz
Buradaki base aslýnda Result'ý iþaret etmektedir.
Resulttaki ilk constructor success ve message parametreleri alýyordu.
Burada da succes olduðu için ona true diyoruz ve bir message parametresi giriyoruz.
26)ProductManager'da artýk add metodunda result yerine successresult ý çaðýrabiliriz.
27) ErrorResult ' ta oluþturalým.
28) ErrorResult için Business katmanýnda döndüreceðimiz string ler için bir yapý oluþturacaðýz.
29)Business ta Constants folder ý oluþturalým. Veritabanýmýza özel proje sabitlerini burada oluþtururuz.
30) Constants'ta Messages static bir class oluþturalým. Static verdiðimizde new lemeyz.
31)ProductManager'da artýk ErrorResult ve SuccesResult'ta Messages daki statik sabitlerimizi çaðýrabiliriz.
32)IProductService te GetAll için de IDataResult döndürsün.
Hem data, hem mesajý, hemde iþlem sonucu içeren bir yapýyý görevi görsün.
33) Core-Utilities-Results altýnda IDataResult interface oluþturalým.
Bu IDataResult ayný zamanda bir de IResult olacak çünkü orada mesaj ve iþlem sonucu da içermektedir.
34)IProductService'teki GetAll'da IDataResult<List<Product>> döndürecek.
Add metodu IResult kalýyor çünkü o bir void metottu Data içermiyor.
35)ProductManager'daki interface metodlarý artýk IDataResult istediði için onlarý güncelleyeceðiz.
Ayrýca return'lerde IDataResult'ýn somutu olan DataResult döndürmeliyiz.
Bunun için Results folderý na DataResult class ý oluþturalým.
Bunun Result'tan farklý data da içermesidir.
36) DataResult, hem Result hem de IDataResult 'týr.
37) Result için SuccessResult ve ErrorResult yaptýk;
DataResult için de SuccessDataResult ve ErrorDataResult yapalým.
38)SuccesDataResult ta çeþitli versiyonlar oluþturuyoruz.
39)Benzer þeyleri ErrorDataResult için de yap ve true larý false yapalaým.
40) ProductManager da return'lerde artýk ErrorDataResult ve SuccessDataResult new lenecek.
41) Program.cs'de ProductTest metodunda GetProductDetails artýk IDataResult döndürüyor onun için metodun
sonuna .Data yapalým.
42) ProductTest'te if koþullarý ekliyoruz.
43)Messages classýnda MaintenanceTime ile ProductsListed'ý string olarak açýklamasýný yazalým.
Onlarý da public yap internal yerine.


11.GÜN SONU KAYIT NOTLARI WEB API

Asp.net, .net projelerideki wep projesidir.
Api, bir Restful mimariyi destekler.
Restful mimari bizim geliþtiridðimiz .net'i tanýmayan sistemlerin entegre olmasýný saðlayan ortamdýr.

1) Solution üzerinde Add Project -> Asp.net core web application
WebAPI için API'yý seçip uygun core versionumzu seçip create yapýyoruz.

2) Postmann test ortamýmýz.

3) WebAPI set as startup project yapýyoruz.

4) Controllers folder ý gelen bütün istekleri karþýlar.
Aslýnda bizim IProductService'teki metodlar için istek oluþturacaðýz.

5) Ýstekler http ile gelecektir.

6) Controllers ta bize gelecek istekleri kodluyoruz aslýnda.

7) Controllers folderýna sað týkla Controllersý seç;
API'yý seçip empty olaný ekliyoruz. API'lerde controller isimleri çoðul yazýlýr.
Bu yüzden ProductsController oluþturuyoruz.

8) ProductsController'de artýk Business'taki datalarý çaðýracaðýz.

9) Web API'ye, add project reference yapýyoruz.
Business, Core, DataAccess ve Entities için.

10) ProductsController' de Get için metod yazýyoruz List<Product> döndüren

11) Bir katman diðer katmanýn somutuyla baðlantý kurmamalý. !!!

12) IProductService'i constructor injection yapýypruz.

13) Bundan sonra çalýþtýrdðýmýzda hata alýyoruz çünkü Web Api somut bir nesne almadýðý için hangi
manageri döndüreceðini bilmiyor oyüzden IoC devreye giriyor.

14) IoC Container aslýnda soyut varlýklarýmýzýn somutlarýný referans olarak tutan bir liste olarak
düþünebiliriz. Web Api'ye soyut varlýðýmýzý refere ettiðimizde onun IoC'deki somutunun referansýný döndürür.

15) WebApi'nin içinde Startup.cs ye gidiyoruz þimdi.

16) services.AddSingleton<IProductService,ProductManager>();
Sen IProductService görüyorsan bunu ProductManager new le diye ifade ederiz.
AddSingleton'ý içinde data tutmadýðýmýz yapýlar için kullanýrýz.

17) Burada da ProductManager contructor'ý da içinde IProductDal içerdiði için,
bunu da AddSingleton'da bunun EfProductDal olduðu ifade etmemiz lazým.

18) Bu yapýyý farklý bir mimariye taþýyacaðýz.
Autofac, Ninject, CastleWindsor, StructureMap, LightInject, DryInject -->IoC Container

19) Artýk AOP yapacaðýz.
AOP= Bütün metodlarýmýzý log lamak istediðimizde kullanýrýz.
Bir metodun önünde, sonunda ve ya bir metot hata verdiðinde çalýþan kodlarý
AOP'de yazýyoruz.  Log vb. için

20) Postman daki Status kýsmý Server'ýn ne döndürdüðünü ifade eder.
Örneðin yetkisi olmayanlar için status 400K olur. Yni buradan alýnan yanýta göre ekran
yapýlandýrýlacak.

21) ProductController deki Get IActionResult olacak þekilde düzeltelim.

22) Get metodunu result.Success ise döndüreceðimiz status için duruma göre Ok ve BadRequest olarak
döndürelim.

23) ProductManager'da bu durumu test edelim çalýþtýðým saatte sistem bakýmda olsun.
Status'te ne dönecek test edelim.

24) Status 400 Bad Request olarak güncellendi sonuçta.
Çünkü ben saat 16:00'da sistem bakýmda dedim.

25) Þimdi post requesti yazacaðýz.

[HttpPost]

26) Post metoduna nesne olarak Product'ý verebiliriz.

27) Post request'lerde data vermemiz lazým.
Postman'da Post'u seçip send dedikten sonra
Body -> raw -> JSON'ý seçelim. Burada JSON formatýnda Product giriþi yapmamýz lazým.
Bunun için Get'ti çalýþtýrýp oradan gelen JSON formatýný kopyalayabiliriz.

    {
        "categoryId": 1,
        "productName": "Bardak",
        "unitsInStock": 15,
        "unitPrice": 25
    }

28) Bunu send ettiðimizde artýk veritabanýna bu bilgileri ekler.

29) Bir Get daha oluþturalým. Bunun için ilkine [HttpGet("getall")]
ikincisine [HttpGet("getbyid")] ; post için de [HttpPost("add")]
Metotlarýn adýný da Get=GetAll vb. yapalým

30) Postman'da artýk GET'TE api/products/getall ; getbyid?id=1 
POST'TA api/products/add kullanarak veri giriþi yapabiliriz.

31) Update ve Delete içinde Post kullanýlabilir.Ama update içinde HttpPut da var.


















