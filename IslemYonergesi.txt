
CORE Katmanı = Framework yapacağız bu yaptığımızı farklı projelerimizde de kullanabileceğiz. Bunu EfProductDal ve EfCategoryDal için yapmamız gerekiyor çünkü bunlar aynı şeyleri yapıyor sadece alınan paremetreler değişiyor.
Bunun için Class Library oluşturmalıyız. Core -> Class Library

Bu CORE Katmanında evrensel kodlarımı yazabilirim.

CORE Katmanında DataAccess folderı data access için evrensel kodlarımı yazıyorum demektir.

NameSpace : Classları Interface lerı belli bir isim uzayında bırakıyoruz ki rahatça erişebilielim diye.

***CORE Katmanı diğer katmanları referans almaz.Ozaman sadece o projeye bağımlı olacaktır bunu istemiyoruz.

IEntityRepository ve IEntity katmanlarının Nortwind database i ile bir bağlantısı yok. Bunlar global oyüzden CORE Katmanına atmamız lazım.

CORE Katamnına da veri tabanı eklememiz lazım oyüzden Solutiın sağ click manage nuget aç ınstall de EntityFrameWrodkCoreSQLSERVER'I CORA EKLE

EfProductDal artık EfEntitiyRepositoryBase'i inherit alacaktır. Çünkü IProductDal'a ilişkin methodlar artık orada.
Burada IProductDal'ı da inherit etmemiz lazım. Bunu farklı server'lar bağlamak için lazım. IProductDal'ı product tablosuna ilişkin operasyonları kullanmak için kullanacağız.

Yeni bir Order class ı eklemek istersek;
1) Entities Class Library'de Order Class ı oluşturulur.
2) Data Access Class Library'de Abstract'ta Interfacı oluşturulur ve bu Interface IEntityRepository olduğu implement et.
3) Data Access Class Library'de EntityFrameWork'te EfOrderDal'ı hazırla. Bunun da EfEntityRepositoryBase<Order, NorthwindContext>,IOrderDal olduğunu belirt.
Bundan sonra tüm sql operasyonların hazır olmuş oluyor.

4) Veri tabanı Context'inde database'deki tablo ile bu yeni oluşturdum Order Class'ının bağlamam lazım.

5) Business'ta Abstract Interface oluşturacağız. Burada Order'la ilgili dış dünyaya neyi servis etmek istiyorsak o operasyonları yazıyoruz.

6) Business Concrete'te Order'ın iş sınıflarını yazıyoruz.


7) Businnes manager sınıflarıma Data Access'teki ilgili Interface'i implement ediyorum IOrderDal _orderDal;

8) Program.cs'de de daha önce yazdığımz kodları metod haline getirmek için seçip sağ clikten quick actions refractoring ' i seçip metod yaptık.

9) DTO (Data Transformation Object) : Join gibi operasyonları yapıyoruz. Entities'te klasor olarak oluştur.

10) DTOs clasorunde ProductDetailDto classı oluştur.

11) Core altında Entitites'te IDtos interface i oluşturulmalıdır.
ProductDetailDto:IDto yapmayı unutma.

12) DataAccess'teki Interface'lerde join yapısı oluşturulacak.

10.GÜN SONU KAYIT NOTLARI WEB API

1) Business'ta IProductService Add metodu ekleyelim.
2)Web API, yazdığımız kodların bir Angular, IOS vb. uygulamaların
anlamasını sağlar.
WEB API ,Restful denilen bir formatla çalışan json uygulamaları
3) Client'ların WEB API'ye yapacakları Requestler ile bizim vereceğimiz
Response ları yönetebilmek için bir alt yapı kuracağız.
4) Bu Request'lere Response döndürecekler Business'taki Managerlerdir.
Oyüzden orası için Base bir katman yazacağız.
5)Business'ta IProductService GetById metodu ekleyelim.
6) Bir metodtta sadece bir şey döndürebilirsin ama bir den fazla şey döndürmek istersen
Encapsulation yapman lazım.
7) Core Katmanına Utilities(Araçlar) folderı ekleyelim.
8) Utilities'te de bir Results klasorü ekleyeceğiz Response larımız için.
Bu Result klasörü bizim result larımızı düzenleyecek.
9) Result klasöründe IResult interfacı oluşturalım.
10) IResult ın somut classını Result olarak oluştur.
11) Result'ta IResult ı implement ettikten sonra return tarafına {get;}
12) IProductService eklediğimiz Add metodunu void değil artık IResult döndürmeli
13) ProductManager'da da ilgili void yerine IResult yapıyoruz. (Add metodu)
14) Bu Add metoduna return olarak artık Result vermeliyiz.
15) return new Result(true,"Ürün eklendi.");
16) Burada Result'a çift tıklayıp ampülden üsttekini seçiyoruz ve Reulst'a F12 ile gidiyoruz.
17) private değişkenleri ve metodun içindeki this leri siliyoruz.
17) Result'ta contructor kurulduğu için burada Message=message yapıyoruz yani aslında sadece get yapılabilen değişlenleri
Contructor ile set leyebiliyoruz.
18) Add çalıştıktan sonra mesaj döndürmek istemiyorsak ne yapacağız?
19) succes ve message parametresi alan constructor ı overload edecek sadece succes
parametresi alan bir Result contructor daha yazıyoruz.
20) public Result(bool success, string message):this(success)
        {
            Message = message;
        }

        public Result(bool success)
        {
            Success = success;
        }
21) this ile Result'ın sadece success alan parametreli contructorı da çalışşın diyoruz.
22) Dolayısıyla ProductManager'da IResult döndüren Add methodunda
iki parametreli Result'ı new lersen Result.cs de iki contructor da çalışacak.
23) Bu yapıyı şimdi biraz daha profesyonel yapalım. SuccessResult, ErrorResult vb.
24) Results folderında SuccessResult yaratalım bu aynı zamanda Result,
burada Result contructor içerdiği için SuccessResult içinde constructor olmalı
25)SuccessResult construtorı oluşturuyoruz ve ;
public SuccessResult(string message):base(true,message) böyle tanımlıyoruz
Buradaki base aslında Result'ı işaret etmektedir.
Resulttaki ilk constructor success ve message parametreleri alıyordu.
Burada da succes olduğu için ona true diyoruz ve bir message parametresi giriyoruz.
26)ProductManager'da artık add metodunda result yerine successresult ı çağırabiliriz.
27) ErrorResult ' ta oluşturalım.
28) ErrorResult için Business katmanında döndüreceğimiz string ler için bir yapı oluşturacağız.
29)Business ta Constants folder ı oluşturalım. Veritabanımıza özel proje sabitlerini burada oluştururuz.
30) Constants'ta Messages static bir class oluşturalım. Static verdiğimizde new lemeyz.
31)ProductManager'da artık ErrorResult ve SuccesResult'ta Messages daki statik sabitlerimizi çağırabiliriz.
32)IProductService te GetAll için de IDataResult döndürsün.
Hem data, hem mesajı, hemde işlem sonucu içeren bir yapıyı görevi görsün.
33) Core-Utilities-Results altında IDataResult interface oluşturalım.
Bu IDataResult aynı zamanda bir de IResult olacak çünkü orada mesaj ve işlem sonucu da içermektedir.
34)IProductService'teki GetAll'da IDataResult<List<Product>> döndürecek.
Add metodu IResult kalıyor çünkü o bir void metottu Data içermiyor.
35)ProductManager'daki interface metodları artık IDataResult istediği için onları güncelleyeceğiz.
Ayrıca return'lerde IDataResult'ın somutu olan DataResult döndürmeliyiz.
Bunun için Results folderı na DataResult class ı oluşturalım.
Bunun Result'tan farklı data da içermesidir.
36) DataResult, hem Result hem de IDataResult 'tır.
37) Result için SuccessResult ve ErrorResult yaptık;
DataResult için de SuccessDataResult ve ErrorDataResult yapalım.
38)SuccesDataResult ta çeşitli versiyonlar oluşturuyoruz.
39)Benzer şeyleri ErrorDataResult için de yap ve true ları false yapalaım.
40) ProductManager da return'lerde artık ErrorDataResult ve SuccessDataResult new lenecek.
41) Program.cs'de ProductTest metodunda GetProductDetails artık IDataResult döndürüyor onun için metodun
sonuna .Data yapalım.
42) ProductTest'te if koşulları ekliyoruz.
43)Messages classında MaintenanceTime ile ProductsListed'ı string olarak açıklamasını yazalım.
Onları da public yap internal yerine.


11.GÜN SONU KAYIT NOTLARI WEB API

Asp.net, .net projelerideki wep projesidir.
Api, bir Restful mimariyi destekler.
Restful mimari bizim geliştiridğimiz .net'i tanımayan sistemlerin entegre olmasını sağlayan ortamdır.

1) Solution üzerinde Add Project -> Asp.net core web application
WebAPI için API'yı seçip uygun core versionumzu seçip create yapıyoruz.

2) Postmann test ortamımız.

3) WebAPI set as startup project yapıyoruz.

4) Controllers folder ı gelen bütün istekleri karşılar.
Aslında bizim IProductService'teki metodlar için istek oluşturacağız.

5) İstekler http ile gelecektir.

6) Controllers ta bize gelecek istekleri kodluyoruz aslında.

7) Controllers folderına sağ tıkla Controllersı seç;
API'yı seçip empty olanı ekliyoruz. API'lerde controller isimleri çoğul yazılır.
Bu yüzden ProductsController oluşturuyoruz.

8) ProductsController'de artık Business'taki dataları çağıracağız.

9) Web API'ye, add project reference yapıyoruz.
Business, Core, DataAccess ve Entities için.

10) ProductsController' de Get için metod yazıyoruz List<Product> döndüren

11) Bir katman diğer katmanın somutuyla bağlantı kurmamalı. !!!

12) IProductService'i constructor injection yapıypruz.

13) Bundan sonra çalıştırdğımızda hata alıyoruz çünkü Web Api somut bir nesne almadığı için hangi
manageri döndüreceğini bilmiyor oyüzden IoC devreye giriyor.

14) IoC Container aslında soyut varlıklarımızın somutlarını referans olarak tutan bir liste olarak
düşünebiliriz. Web Api'ye soyut varlığımızı refere ettiğimizde onun IoC'deki somutunun referansını döndürür.

15) WebApi'nin içinde Startup.cs ye gidiyoruz şimdi.

16) services.AddSingleton<IProductService,ProductManager>();
Sen IProductService görüyorsan bunu ProductManager new le diye ifade ederiz.
AddSingleton'ı içinde data tutmadığımız yapılar için kullanırız.

17) Burada da ProductManager contructor'ı da içinde IProductDal içerdiği için,
bunu da AddSingleton'da bunun EfProductDal olduğu ifade etmemiz lazım.

18) Bu yapıyı farklı bir mimariye taşıyacağız.
Autofac, Ninject, CastleWindsor, StructureMap, LightInject, DryInject -->IoC Container

19) Artık AOP yapacağız.
AOP= Bütün metodlarımızı log lamak istediğimizde kullanırız.
Bir metodun önünde, sonunda ve ya bir metot hata verdiğinde çalışan kodları
AOP'de yazıyoruz.  Log vb. için

20) Postman daki Status kısmı Server'ın ne döndürdüğünü ifade eder.
Örneğin yetkisi olmayanlar için status 400K olur. Yni buradan alınan yanıta göre ekran
yapılandırılacak.

21) ProductController deki Get IActionResult olacak şekilde düzeltelim.

22) Get metodunu result.Success ise döndüreceğimiz status için duruma göre Ok ve BadRequest olarak
döndürelim.

Çalıştırdığımızda açılan browser da url alanına domain den sonra api/httpger ve ya post'un içine ne yazdıysak öyle çağırıyoruz.
örneğin domain/api/products/getall

23) ProductManager'da bu durumu test edelim çalıştığım saatte sistem bakımda olsun.
Status'te ne dönecek test edelim.

24) Status 400 Bad Request olarak güncellendi sonuçta.
Çünkü ben saat 16:00'da sistem bakımda dedim.

25) Şimdi post requesti yazacağız.

[HttpPost]

26) Post metoduna nesne olarak Product'ı verebiliriz.

27) Post request'lerde data vermemiz lazım.
Postman'da Post'u seçip send dedikten sonra
Body -> raw -> JSON'ı seçelim. Burada JSON formatında Product girişi yapmamız lazım.
Bunun için Get'ti çalıştırıp oradan gelen JSON formatını kopyalayabiliriz.

    {
        "categoryId": 1,
        "productName": "Bardak",
        "unitsInStock": 15,
        "unitPrice": 25
    }

28) Bunu send ettiğimizde artık veritabanına bu bilgileri ekler.

29) Bir Get daha oluşturalım. Bunun için ilkine [HttpGet("getall")]
ikincisine [HttpGet("getbyid")] ; post için de [HttpPost("add")]
Metotların adını da Get=GetAll vb. yapalım

30) Postman'da artık GET'TE api/products/getall ; getbyid?id=1 
POST'TA api/products/add kullanarak veri girişi yapabiliriz.

31) Update ve Delete içinde Post kullanılabilir.Ama update içinde HttpPut da var.


















